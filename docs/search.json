[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmieren mit Stata",
    "section": "",
    "text": "Dies ist das Begleitskript zum Kurs Programmieren mit Postestimates, Macros und Schleifen in Stata am BIBB von Andreas Filser.\nMelden Sie sich gerne bei Fragen oder Wünschen unter andreas.filser[at]uol.de\n\n   Montag 24.10.2022\n   8:30 - 17:00 Uhr\n   Webex"
  },
  {
    "objectID": "01_macros.html",
    "href": "01_macros.html",
    "title": "1  Macros",
    "section": "",
    "text": "Macros ist die Sammelbezeichung für globals und locals in Stata. Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen. Definiert werden sie durch globalinhalt oder localinhalt - oft mit glo und loc als Abkürzungen. globals können dann mit $globalname/${globalname} aufgerufen werden, locals mit `localname' - ganz einfach bspw. mit dis[play]:\n…oder mit macro list, hier sind die macros aber ohne “punctuation” (also $ oder `')\nDer Unterschied besteht vor allem darin, dass local macros ‘lokal’ für ein spezifisches Programm verfügbar sind, globale macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind. Letztlich können wir jede Instanz, in der wir mehrere Zeilen eines DoFiles ausführen als ‘Programm’ ansehen.\nglobals können wir später nochmal aufrufen, locals nicht:"
  },
  {
    "objectID": "01_macros.html#macht-einen-unterschied",
    "href": "01_macros.html#macht-einen-unterschied",
    "title": "1  Macros",
    "section": "1.1 = macht einen Unterschied",
    "text": "1.1 = macht einen Unterschied\nIn der Regel können wir auch einfach glo glname Wert bzw. loc locname Wert statt glo glname = Wert bzw. loc locname = Wert angeben. Allerdings ist hier etwas Vorsicht geboten, denn das = ist entscheidend ob die Rechnung abgelegt wird oder das Ergebnis (Stichwort evaluation):\n\nMit = : der Ausdruck wird “evaluated”\nOhne = : der Ausdruck wird “aliased”\n\nIm Ergebnis sehen wir hier beides Mal das gleiche:\n\nlocal m1 2+2\ndisplay `m1'\n\n4\n\n\n\nlocal m2 = 2+2\ndisplay `m2'\n\n4\n\n\nAber wenn wir uns mit mac list die abgelegten Infos ansehen, dann sehen wir den entscheidenden Unterschied:\n\nmac list _m1 _m2\n\n\n\n_m1:            2+2\n_m2:            4\n\n\nWenn wir nämlich mit m1 und m2 weiterrechnen, da kann folgendes passieren:\n\nlocal m1 2+2\ndisplay `m1'*4\n\n10\n\n\n\nlocal m2 = 2+2\ndisplay `m2'*4\n\n16\n\n\nDenn \\(2+2*4\\neq4*4\\)"
  },
  {
    "objectID": "01_macros.html#local-und-global-sind-getrennte-welten",
    "href": "01_macros.html#local-und-global-sind-getrennte-welten",
    "title": "1  Macros",
    "section": "1.2 local und global sind getrennte Welten",
    "text": "1.2 local und global sind getrennte Welten\nGeht, aber ist nicht zu empfehlen:\n\nglo yx = 1\nloc yx = 2\nmac list yx\nmac list _yx\n\nyx:             1\n\n_yx:            2"
  },
  {
    "objectID": "01_macros.html#macros-mit-text",
    "href": "01_macros.html#macros-mit-text",
    "title": "1  Macros",
    "section": "1.3 Macros mit Text",
    "text": "1.3 Macros mit Text\nWir können macros zu Texten zusammenbauen:\n\nglo t1 \"Hallo\"\nglo t2 \" zusammen\"\nglo t3 \"! :-)\"\n\nglo t4 = \"${t1}${t2}${t3}\"\ndis \"${t4}\"\nmac list t1 t2 t3 t4\n\nHallo zusammen! :-)\n\nt1:             Hallo\nt2:              zusammen\nt3:             ! :-)\nt4:             Hallo zusammen! :-)\n\n\n\nÜbung"
  },
  {
    "objectID": "01_macros.html#dateipfade",
    "href": "01_macros.html#dateipfade",
    "title": "1  Macros",
    "section": "1.4 Dateipfade",
    "text": "1.4 Dateipfade\nEin macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden:\n\nglo pfad \"D:\\Projekt\\daten\\BIBB_BAuA\" // wo liegt der Datensatz?\nuse \"${pfad}/BIBBBAuA_2018_suf1.0.dta\", clear // laden des Datensatzes \n\nWir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden:\n\n\n\n\n\n\n\n\n\n\nglo pfad \"C:\\Projekte\\Micha\" // wo liegt der Datensatz bei Alex?\nglo pfad \"D:\\Arbeit\\Alex\"    // wo liegt der Datensatz bei Micha?\n\nglo prog \"${pfad}/prog\"  \nglo data \"${pfad}/data\"\nglo log  \"${pfad}/log\"\n\nMicha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. Wir lernen gleich noch eine Möglichkeit kennen, das auch direkt mit zu lösen mit dem Usernamen der verwendeten PCs.\n\nuse \"${data}/BIBBBAuA_2018_suf1.0.dta\", clear // laden des Datensatzes \n\nDie \" \" sind nicht zwingend nötig in diesem Fall. Sollten aber Leerzeichen im Pfad vorkommen, brauchen wir auf jeden Fall \" \". Außerdem ist \\ beim Zusammenbauen mit macros manchmal problematisch) - auch hier helfen \" \". Alternativ hilft hier / statt \\ zu verwenden.\nMit mkdir können wir auch Ordner erstellen. Wenn also noch kein log-Ordner existiert, können wir ihn so erstellen:\n\nmkdir ${log}\n\nMit cap cd können wir das vorher überprüfen:\n\ncapture cd  \"${log}\"\n    if _rc!=0  {\n        mkdir ${log}\n        display \"${log} erstellt\"\n    } \n\nSiehe 01_init_beispiel.do für ein Beispiel für einige Befehle beim Erstellen eines Projektverzeichnisses."
  },
  {
    "objectID": "01_macros.html#cmac",
    "href": "01_macros.html#cmac",
    "title": "1  Macros",
    "section": "1.5 Bereits definierte Macros",
    "text": "1.5 Bereits definierte Macros\nMit mac list bekommen wir auch einige von Stata bereits vorgegebenen Macros angezeigt.\n\nmac list\n\nZwei sehr nützliche sind dabei $S_DATE $S_TIME - das aktuelle Datum und die aktuelle Zeit:\n\ndis \"$S_DATE\"\ndis \"$S_TIME\"\n\n\n2 May 2022\n12:44:22\n\nDiese können wir beispielsweise am Anfang und Ende eines Abschnitts in einem LogFiles einblenden, um Start- und Endzeit zu dokumentieren:\n\nlog using \"${log}/logfile.txt\", t replace\nuse ....\ndis \"Start: $S_DATE um $S_TIME\"\n.\n.\nHier kommen aufwändige Modelle\n.\n.\n.\ndis \"Ende: $S_DATE um $S_TIME\"\n.\n.\n.\ncap log close\n\nSo können wir beispielsweise automatisch log-Files mit einem Datum versehen:\n\nglobal date = string( d($S_DATE), \"%tdCY-N-D\" )\n* help datetime_display_formats // für andere Datumsformate\n\ncap log close\nlog using \"${log}/01_macro_loops_${date}.log\", replace text\n\n\n. log using \"${log}/01_macro_loops_${date}.log\", replace text\n(note: file D:\\Arbeit\\Alex/log/01_macro_loops_2021-12-01.log not found)\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n      name:  <unnamed>\n       log:  D:\\Arbeit\\Alex/log/01_macro_loops_2021-12-01.log\n  log type:  text\n opened on:  01 Dec 2021, 10:45:04\n\nAußerdem gibt es einige locals mit nützlichen Infos:\n\ndis \"`c(username)'\"\ndis \"`c(machine_type)'\"\ndis \"`c(os)'\"\n\n\nFilser\nPC (64-bit x86-64)\nWindows\n\nWeitere “system parameters and settings” unter help creturn bspw.:\n\nc(changed) returns a numeric scalar equal to 0 if the dataset in memory has not changed since it was last saved and 1 otherwise.\nc(filename) returns a string containing the filename last specified with a use or save, such as \"C:\\Data\\auto.dta\".\nc(filedate) returns a string containing the date and time the file in c(filename) was last saved, such as “7 Jul 2016 13:51”.\n\n\n1.5.1 if\nMit if (local== \"...\") können wir macros abgleichen, um Befehle nur unter bestimmten Bedingungen auszuführen:\n\nif (\"`c(username)'\" == \"Filser\")  display \"Du bist Filser\"\nif (\"`c(username)'\" != \"Fischer\") display \"Du bist nicht Fischer\"\n\nDas können wir für den Fall von eben mit mehreren Nutzern nutzen:\n\nif (\"`c(username)'\" == \"Alex\")   glo pfad \"C:\\Projekte\\Micha\" // wo liegt der Datensatz bei Alex?\nif (\"`c(username)'\" == \"Micha\")  glo pfad \"D:\\Arbeit\\Alex\"    // wo liegt der Datensatz bei Micha?\n\nglo prog \"${pfad}/prog\"  \nglo data \"${pfad}/data\"\nglo log  \"${pfad}/log\"\n\nuse \"${pfad}/BIBBBAuA_2018_suf1.0.dta\", clear // laden des Datensatzes \n\nFür if-Bedingungen stehen uns die üblichen Operatoren zur Verfügung, die wir auch aus den if-Statements in Befehlen kennen: >, <, ==, >=, <=, !=/~= (ungleich) Mit | können wir oder-Bedingungen stellen.\n\ninrange: einen Wertebereich auswählen\n\n\nloc x = 20\nif `x' >= 20 & `x' <= 30 display \"& yes\"  \nif inrange(`x',20,30) display \"inrange yes\"\n\n\nloc x = 19\nif inrange(`x',20,30) display \"yes\"\n\n\ninlist: spezifische Werte angeben, um lange Folgen von | zu vermeiden:\n\n\nloc x = 20\nif `x' == 18 | `x' == 20 | `x' == 22 | `x' == 28 display \"| yes\"  \nif inlist(`x',18,20,22,28) display \"inlist yes\"  \n\n\n\n1.5.2 Macros als Variablennamen und Befehle\nAuch so etwas ist möglich:\n\nlocal n 200\nsu F`n'\n\n\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n        F200 |     17,953    36.24272    14.03048          1         99\n\n\nEin macro kann auch ein Programm sein:\n\nloc t tab\n`t' mobil\n\n\n\nMobilfunkin |\n    terview |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Festnetz |     14,008       70.00       70.00\n  Mobilfunk |      6,004       30.00      100.00\n------------+-----------------------------------\n      Total |     20,012      100.00\n\n\n\\(\\Rightarrow\\) sollen macros als Text verstanden werden, sind \"\" nötig:\n\nloc opt ja\nif inlist(`opt',\"ja\",\"JA\",\"Ja\",\"ok\") tab mobil\n\nja not found\nr(111);\n\nend of do-file\nr(111);\n\n\n\nloc opt ja\nif inlist(\"`opt'\",\"ja\",\"JA\",\"Ja\",\"ok\") tab mobil\n\n\n\nMobilfunkin |\n    terview |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Festnetz |     14,008       70.00       70.00\n  Mobilfunk |      6,004       30.00      100.00\n------------+-----------------------------------\n      Total |     20,012      100.00\n\n\n\n\n1.5.3 globals durchsuchen\nMit Hilfe sog. Wildcards können wir Zeichen “offen lassen”:\n\n? ersetzt ein Zeichen\n* mehrere oder keines\n\n\nglo x1 = 2\nglo x2 \"das ist x2\"\nglo x 291\nglobal allglo:  all globals \"x*\"\nglobal allglo2: all globals \"x?\"\nmac l allglo2 allglo\n\nallglo2:        x2 x1\nallglo:         x x2 x1\n\n\nHier haben wir auch schon die dritte Form der macro Definition kennengelernt, die sog. extended macro function, welche auf : folgt. Hier also all globals, im Laufe dieses Kurses werden wir noch zahlreiche dieser Funktionen kennenlernen."
  },
  {
    "objectID": "01_macros.html#wenn-nicht-if-dann-else",
    "href": "01_macros.html#wenn-nicht-if-dann-else",
    "title": "1  Macros",
    "section": "1.6 Wenn nicht if, dann else",
    "text": "1.6 Wenn nicht if, dann else\nMit if haben wir die Möglichkeiten aber noch nicht ausgeschöpft - aus help if:\n\nif `n'==1 {\n    local word \"one\"\n     }\nelse if `n'==2 {\n    local word \"two\"\n}\nelse if `n'==3 {\n    local word \"three\"\n}\nelse {\n    local word \"big\"\n}\ndisplay \"`word'\""
  },
  {
    "objectID": "01_macros.html#unterbrechen-wenn-ein-fehler-vorliegt",
    "href": "01_macros.html#unterbrechen-wenn-ein-fehler-vorliegt",
    "title": "1  Macros",
    "section": "1.7 Unterbrechen wenn ein Fehler vorliegt",
    "text": "1.7 Unterbrechen wenn ein Fehler vorliegt\nMit exit (help exit_program) können wir Stata zu einer Unterbrechung bringen:\n\nexit causes Stata to terminate the current process and returns control to the calling process.\n\n\nif \"`c(username)'\" == \"Alex\" {\n  glo pfad \"C:\\Projekte\\Micha\" // wo liegt der Datensatz bei Alex?\n    } \nelse if \"`c(username)'\" == \"Micha\" {\n  glo pfad \"D:\\Arbeit\\Alex\"    // wo liegt der Datensatz bei Micha?\n}\nelse {\n display as error \"Hier fehlt der passende Pfad\"\n exit \n}\ntab mobil\n\nHier fehlt der passende Pfad\n\nend of do-file\n\n\n\nÜbung"
  },
  {
    "objectID": "01_macros.html#schleifen-foreach-forvalues",
    "href": "01_macros.html#schleifen-foreach-forvalues",
    "title": "1  Macros",
    "section": "1.8 Schleifen: foreach & forvalues",
    "text": "1.8 Schleifen: foreach & forvalues\nSchleifen helfen uns das DRY (“Don’t repeat yourself”) Prinzip umzusetzen.\n\ntab S1 if zpalter <= 19\ntab S1 if zpalter <= 24\ntab S1 if zpalter <= 29\n\nforeach v of numlist 19(5)29 {\n    display \"Alter bis `v'\"\n    tab S1 if zpalter <= `v'\n}\n\nEin vereinfachtes Syntaxdiagramm der foreach-Schleife sieht so aus:\n\nforeach lname listtype list {\n  Befehle\n}\n\nlname steht dabei für ein local macro.\nWir können unterschiedliche Typen von foreach-Listen verwenden:\n– of varlist: Variablenlisten\n– of newlist: neue Variablen\n– of numlist: Nummernlisten - bspw. (0(1)5) \\(\\Rightarrow\\) “1 bis 5 in Schritten von 1” weitere Varianten\n– in: beliebige Listen von Buchstaben, Zahlen oder Wörtern (durch Leerzeichen getrennt)\n\nforeach lname in any_list {\nforeach lname of local    local      {\nforeach lname of global   global     {\nforeach lname of varlist  variablen  { //auch Wildcards möglich - analog zu d F2**\nforeach lname of newlist  newvarlist { //wenn variablen erst generiert werden\nforeach lname of numlist  numlist    {\n\n\nforeach n of numlist 1/3 6(1)9  {\n    dis \"`n'\"\n}\n\n1\n2\n3\n6\n7\n8\n9\n\n\n\nforeach n of numlist 6 4: -4  {\n    dis \"`n'\"\n}\n\n6\n4\n2\n0\n-2\n-4\n\n\n\n1.8.1 ferest()\nMit ferest() können wir uns die “noch übrigen Werte in der Liste anzeigen lassen:\n\nforeach n of numlist 1(1)5 {\n    dis \"`n'\"\n    dis \"Es kommen noch: `ferest()'\"\n}\n\n1\nEs kommen noch: 2 3 4 5\n2\nEs kommen noch: 3 4 5\n3\nEs kommen noch: 4 5\n4\nEs kommen noch: 5\n5\nEs kommen noch: \n\n\n\n\n1.8.2 Weitere Schleifentypen\nEs gibt außerdem forvalues:\n\nforvalues lname=range {\n  Befehle\n}\n\nforvalues-Schleife ist eine foreach-Schleife mit numlist. Aber: Die foreach-Schleife mit einer numlist funktioniert nicht mit einer beliebig hohen Anzahl von Ziffern. In der forvalues-Schleife gibt es keine Beschränkung. Außerdem ist forvalues-Schleife schneller im Abarbeiten von Nummernlisten.\nUnd dann gibt es noch die while-Schleife:\n\nloc i = 1\nwhile `i' <= 5 {\n  display \"`i'\"\n  loc i = `i' + 1\n}\n\n1\n2\n3\n4\n5\n\n\nEine Besonderheit bei locals ist, dass wir mit loc ++i den Wert um 1 erhöhen können. Somit führt folgende Syntax zum gleichen Ergebnis:\n\nloc i = 1\nwhile `i' <= 5 {\n  display \"`i'\"\n  loc ++i\n}\n\n\n\n1.8.3 Anwendung\n\nforeach v of numlist 19(5)35 {\n    display \"Alter bis `v'\"\n    tab S1 if zpalter <= `v'\n}\n\n\n\nAlter bis 19\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |         41       67.21       67.21\n   weiblich |         20       32.79      100.00\n------------+-----------------------------------\n      Total |         61      100.00\nAlter bis 24\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |        373       65.10       65.10\n   weiblich |        200       34.90      100.00\n------------+-----------------------------------\n      Total |        573      100.00\nAlter bis 29\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |        991       60.46       60.46\n   weiblich |        648       39.54      100.00\n------------+-----------------------------------\n      Total |      1,639      100.00\nAlter bis 34\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |      1,984       59.03       59.03\n   weiblich |      1,377       40.97      100.00\n------------+-----------------------------------\n      Total |      3,361      100.00\n\n\n…oder mit inrange(), um lediglich die 5-Jahresaltersgruppe anzuzeigen:\n\nforeach v of numlist 19(5)35 {\n    display \"Alter \" `v' - 4 \" bis \" `v'\n    tab S1 if inrange(zpalter,`v'-4, `v')\n    *su zpalter if inrange(zpalter,`v'-4, `v')\n}\n\n\n\nAlter 15 bis 19\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |         41       67.21       67.21\n   weiblich |         20       32.79      100.00\n------------+-----------------------------------\n      Total |         61      100.00\nAlter 20 bis 24\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |        332       64.84       64.84\n   weiblich |        180       35.16      100.00\n------------+-----------------------------------\n      Total |        512      100.00\nAlter 25 bis 29\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |        618       57.97       57.97\n   weiblich |        448       42.03      100.00\n------------+-----------------------------------\n      Total |      1,066      100.00\nAlter 30 bis 34\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |        993       57.67       57.67\n   weiblich |        729       42.33      100.00\n------------+-----------------------------------\n      Total |      1,722      100.00\n\n\n\n\n1.8.4 Schleifen aufbauen\nEinfache Schleife mit if/else: ist Zahl gerade oder ungerade?\n\nloc n = 5\nif trunc(`n'/2) == `n'/2 display \"ja\"\nif trunc(`n'/2) != `n'/2 display \"nein\"\n\nloc n = 5\ndis mod(`n',2) \n\n\nforvalues n = 1/10 {\n    if  mod(`n',2)  == 0 dis \"`n' ist gerade\"\n    if  mod(`n',2)  >  0  dis \"`n' ist ungerade\"\n}\n\nforvalues n = 1/10 {\n    if  mod(`n',2)  == 0 {\n        dis \"`n' ist gerade\"\n    }\n    else if mod(`n',2)  > 0 {\n        dis \"`n' ist ungerade\"\n    } \n}\n\nmod() ist der Modulo-Operator in Stata - es wird der “Rest” berechnet\n\n\n1.8.5 nested loop\n\nforvalues n1 = 1/3 {\n  forvalues n2 = 1/3 {\n    dis \"n1 ist `n1' und n2 ist `n2' \"\n  }\n}\n\nn1 ist 1 und n2 ist 1 \nn1 ist 1 und n2 ist 2 \nn1 ist 1 und n2 ist 3 \nn1 ist 2 und n2 ist 1 \nn1 ist 2 und n2 ist 2 \nn1 ist 2 und n2 ist 3 \nn1 ist 3 und n2 ist 1 \nn1 ist 3 und n2 ist 2 \nn1 ist 3 und n2 ist 3 \n\n\n\n\n1.8.6 display vs. macro list\nmacro list stoppt das DoFile wenn der macro nicht existiert, display zeigt nur ein leeres Feld an:\n\nglobal labormarket LABOUR\n\ndisplay \"${labormarket}\"\ndisplay \"${labourmarket}\"\n\n\nLABOUR\n\n\nmac list labormarket\nmac list labourmarket\n\n\nlabormarket:    LABOUR\n\nglobal macro $labourmarket not found\nr(111);\n\n\nÜbung"
  },
  {
    "objectID": "01_macros.html#übungen",
    "href": "01_macros.html#übungen",
    "title": "1  Macros",
    "section": "1.9 Übungen",
    "text": "1.9 Übungen\n\n1.9.1 Übung\n\nWas ist das Ergebnis dieser Rechnung? Nehmen Sie sich einen Moment Zeit und rechnen Sie im Kopf - Überprüfen Sie dann ihr Ergebnis.\n\n\nloc x = 4\nglo y = 1+5\nloc y 1+5\ndis `x' * `y'\n\n\nWie können Sie hier aus Hallo zusammen! :-) folgende Ausgabe machen: Hallo, zusammen! :-) ohne die macros zu verändern oder einen neuen anzulegen?\n\n\nglo t1 \"Hallo\"\nglo t2 \" zusammen\"\nglo t3 \"! :-)\"\n\nglo t4 = \"${t1}${t2}${t3}\"\ndis \"${t4}\"\n\n\n\n1.9.2 Übung\n\nPfad zusammenbauen für use: Erstellen Sie den Pfad für den use-Befehl schrittweise und unter Berücksichtigung Ihres Usernamens.\n\nggf. Dateiverzeichnis einrichten mit Ordner log, prog und data (gerne auch mehr oder andere Namen)\nLegen Sie die Erwerbstätigenbefragung 2018 in den data-Ordner (oder dessen Äquivalent)\nWie ist der Username auf Ihrem Gerät?\nVerwenden Sie ein if-Statement, um den Dateipfad zu erstellen\nErstellen Sie ein LogFile, welches das heutige Datum im Namen trägt.\n\nLassen Sie sich alle globals, die mit “S” beginnen, in ein gobal allS ablegen. Was wurde alles gefunden?\n\nDenken Sie an die extended macro function all globals\nWie könnten Sie eine Schleife bauen, die nacheinander alle globals anzeigt, die mit “S” beginnen?\n\n\n\n\n1.9.3 FizzBuzz-Challenge\nFizz Buzz wird/wurde als ein Screening-Instrument für Programmierer*innen verwendet. Fizz Buzz ist ein Kinderlernspiel, bei dem die Kinder üblicherweise im Kreis sitzen und reihum laut von eins aufwärts zählen. Allerdings gibt es drei Regeln:\n\nAlle Zahlen, die durch drei teilbar sind, müssen durch das Wort “Fizz” ersetzt werden\nAlle Zahlen, die durch fünf teilbar sind, müssen durch das Wort “Buzz” ersetzt werden\nWenn eine Zahl durch drei und fünf teilbar ist, dann wird “Fizz Buzz” gerufen.\n\nWie würden Sie mit if & else eine Schleife bauen, welche diese Regeln umsetzt. Was wäre der erste Schritt? Bauen Sie dann die Schleife und lassen Sie die Schleife für den Wertebereich 0-30 laufen.\n\n\n1.9.4 Übung\nPassen Sie die Schleife mit ferest() an, sodass hier im 5. Durchlauf nicht mehr Es kommen noch: steht, sondern Fertig."
  },
  {
    "objectID": "01_macros.html#anhang",
    "href": "01_macros.html#anhang",
    "title": "1  Macros",
    "section": "1.10 Anhang",
    "text": "1.10 Anhang\n\n1.10.1 Windows Dateipfade mit macros\nAus der Stata-Doku zu macros:\nStata uses the  character to tell its parser not to expand macros. Windows uses the  character as the directory path separator. Mostly, there is no problem using a  in a filename. However, if you are writing a program that contains a Windows path in macro path and a filename in fname, do not assemble the final result as ‘path’\\‘fname’ because Stata will interpret the  as an instruction to not expand ‘fname’. \\(\\Rightarrow\\) Instead, assemble the final result as ‘path’/‘fname’. Stata understands / as a directory separator on all platforms.\n\n\n1.10.2 Debugging: Wo ist der Wurm drin?\nFehlersuch in langen foreach-Schleifen kann mühsam und nervig sein. in many cases you would like to go throuh the code step by step then, however, the value of the loop index (which is a local) In vielen Fällen möchte man den Code Schritt für Schritt durchgehen, dann aber den Wert des Schleifen-locals ist natürlich nach Abbruch der Schleife nicht mehr da.\n\nforvalues y = 1982/1985 {\n    use \"${data}/wages-year`y'\", clear\n    capture log close\n    log using \"${data}/log`y'.log\", text replace\n    regress lwage exper expersq educ\n    avplots\n    graph export \"${graph}/avplots`y'.png\", replace\n}\n\nManchmal hilft ein einfacher Workaround: ein global aus dem local definieren:\n\nforvalues y = 1982/1985 {\n    global Y = `y'\n    use \"${data}/wages-year`y'\", clear\n    capture log close\n    log using \"${data}/log`y'.log\", text replace\n    regress lwage exper expersq educ\n    avplots\n    graph export \"${graph}/avplots`y'.png\", replace\n}\n\nAlternativ hilft häufig auch set trace on weiter. Hier werden immer die zuerst die macros und dann die eingesetzten Werte angezeigt:\n\nset trace on\nforeach v of numlist 19(5)35 {\n    display \"Alter \" `v' - 4 \" bis \" `v'\n}\n\n\n\n- foreach v of numlist 19(5)35 {\n- display \"Alter \" `v' - 4 \" bis \" `v'\n= display \"Alter \" 19 - 4 \" bis \" 19\nAlter 15 bis 19\n- }\n- display \"Alter \" `v' - 4 \" bis \" `v'\n= display \"Alter \" 24 - 4 \" bis \" 24\nAlter 20 bis 24\n- }\n- display \"Alter \" `v' - 4 \" bis \" `v'\n= display \"Alter \" 29 - 4 \" bis \" 29\nAlter 25 bis 29\n- }\n- display \"Alter \" `v' - 4 \" bis \" `v'\n= display \"Alter \" 34 - 4 \" bis \" 34\nAlter 30 bis 34\n- }\n\n\n\n\n1.10.3 Einstellung für ssc install an BIBB-Arbeitsrechnern\nHTTP proxy host: kessenich.ivbb.bund.de Port: 80"
  },
  {
    "objectID": "02_loops_fromdata.html#local-erstellen-und-für-schleifen-verwenden",
    "href": "02_loops_fromdata.html#local-erstellen-und-für-schleifen-verwenden",
    "title": "2  Schleifen aus Macros",
    "section": "2.1 local erstellen und für Schleifen verwenden",
    "text": "2.1 local erstellen und für Schleifen verwenden\nSchleifen aus globals / locals mit Hilfe von levelsof:\n\ntab m1202\nlevelsof m1202\n\nlevelsof m1202, loc(ausb)\nforeach lvl  of local ausb {\n    dis \"m1202: \" `lvl'\n}\n\n\nlevelsof m1202, loc(ausb)\nglo ausb `ausb'\nmac l ausb\n\nforeach lvl  of global ausb {\n    dis \"m1202: \" `lvl'\n}\n\n\nforeach lvl  of global ausb {\n    dis \"m1202: \" `lvl'\n    tab S1 if m1202 == `lvl'\n}"
  },
  {
    "objectID": "02_loops_fromdata.html#schleifen-über-strings",
    "href": "02_loops_fromdata.html#schleifen-über-strings",
    "title": "2  Schleifen aus Macros",
    "section": "2.2 Schleifen über strings",
    "text": "2.2 Schleifen über strings\n\n2.2.1 Wörter indizieren\n\nlocal phrase `\" \"2 guys\" \"1 girl\" \"1 pizza place\" \"'\ndi \"`:word 2 of `phrase' '\"\n\n1 girl\n\n\n\n\n2.2.2 Wörter zählen\n\nlocal sentence \"here is a sentence 7\"\nlocal len: word count `sentence'\nmac list _len\n\n_len:           5\n\n\n\n\n2.2.3 Wörter in Schleife\n\nlocal phrase1 \"here is a sentence of 7 words\"\nlocal len1: word count `phrase1'\n\nforvalues i = 1(1)`len1' {\n    loc word: word `i' of `phrase1'\n    dis \"this is word number \" `i' \": `word'\"\n}\n\nthis is word number 1: here\nthis is word number 2: is\nthis is word number 3: a\nthis is word number 4: sentence\nthis is word number 5: of\nthis is word number 6: 7\nthis is word number 7: words\n\n\n… dabei macht es einen Unterschied, wo die \"\" stehen:\n\nlocal phrase2 `\" \"here is\" \"a sentence\" \"of 7 words\" \"'\nlocal len2: word count `phrase2'\n\nforvalues i = 1(1)`len2' {\n    loc word: word `i' of `phrase2'\n    dis \"this is word number \" `i' \": `word'\"\n}\n\nthis is word number 1: here is\nthis is word number 2: a sentence\nthis is word number 3: of 7 words\n\n\n\nÜbung"
  },
  {
    "objectID": "02_loops_fromdata.html#informationen-aus-schleifen-behalten",
    "href": "02_loops_fromdata.html#informationen-aus-schleifen-behalten",
    "title": "2  Schleifen aus Macros",
    "section": "2.3 Informationen aus Schleifen behalten",
    "text": "2.3 Informationen aus Schleifen behalten\n\n2.3.1 Gespeichterte Ergebnisse\nUm auf Ergebnisse zuzugreifen, können wir etwas hinter die Kulissen der Stata-Befehle sehen:\n\n\n\n\n \n  \n    Befehl \n    zeigt alle \n  \n \n\n  \n    c-class \n    system parameters & settings finden wir als `c()` - siehe [``c(username)'`](#cmac) \n  \n  \n    r-class \n    die meisten deskriptiven Befehle speichern die Ergebnisse in in `r()` \n  \n  \n    e-class \n    ...außer estimation commands, wie bspw. `reg` - hier wird in `e()` gespeichert (Postestimates) \n  \n  \n    s-class \n    parsing commands store results in `s()` used by programmers \n  \n  \n    n-class \n    commands that do not store in `r()`, `e()`, oder `s()` \n  \n\n\n\n\n\nJeweils alle Werte anzeigen mit:\n\n\n\n\n \n  \n    Befehl \n    zeigt alle \n  \n \n\n  \n    return list \n    r() \n  \n  \n    ereturn list \n    e() \n  \n  \n    sreturn list \n    s() \n  \n  \n    creturn list \n    c() \n  \n\n\n\n\n\nEs gibt dabei vier Typen an Ergebnissen:\n\nmacro: strings mit mehreren Wörtern (Text)\nmatrix: bspw. e(b) sind die Koeffizienten nach einem reg-Befehl oder e(V) ist die Varianz–Kovarianz Matrix der estimates (VCE)\nscalar: einzelne Zahlen/Strings (1x1 Matrizen)\nfunctions: bspw. e(sample) \\(\\Rightarrow\\) 1 (true) wenn die Beobachtung im vorheringen “estimation command” verwendet wurde und 0 (false) wenn nicht\n\n\ntab S1\nreturn list\n\n\n\n Geschlecht |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   männlich |     10,074       50.34       50.34\n   weiblich |      9,938       49.66      100.00\n------------+-----------------------------------\n      Total |     20,012      100.00\n\n\nscalars:\n                  r(N) =  20012\n                  r(r) =  2\n\n\n\nsu S1\nreturn list\n\n\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n          S1 |     20,012    1.496602    .5000009          1          2\n\n\nscalars:\n                  r(N) =  20012\n              r(sum_w) =  20012\n               r(mean) =  1.496602038776734\n                r(Var) =  .2500009464113147\n                 r(sd) =  .500000946410419\n                r(min) =  1\n                r(max) =  2\n                r(sum) =  29950\n\n\n\nreg F518_SUF zpalter \nereturn list\n\n\n\n      Source |       SS           df       MS      Number of obs   =    16,543\n-------------+----------------------------------   F(1, 16541)     =    105.36\n       Model |  1.3092e+09         1  1.3092e+09   Prob > F        =    0.0000\n    Residual |  2.0555e+11    16,541    12426773   R-squared       =    0.0063\n-------------+----------------------------------   Adj R-squared   =    0.0063\n       Total |  2.0686e+11    16,542    12505168   Root MSE        =    3525.2\n\n------------------------------------------------------------------------------\n    F518_SUF |      Coef.   Std. Err.      t    P>|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n     zpalter |   24.62253   2.398848    10.26   0.000     19.92053    29.32453\n       _cons |    2381.28    115.577    20.60   0.000     2154.736    2607.823\n------------------------------------------------------------------------------\n\n\nscalars:\n                  e(N) =  16543\n               e(df_m) =  1\n               e(df_r) =  16541\n                  e(F) =  105.3561454498825\n                 e(r2) =  .0063290815436915\n               e(rmse) =  3525.162828161657\n                e(mss) =  1309236899.97876\n                e(rss) =  205551251614.9366\n               e(r2_a) =  .0062690083366028\n                 e(ll) =  -158590.4618746699\n               e(ll_0) =  -158642.9792418738\n               e(rank) =  2\n\nmacros:\n            e(cmdline) : \"regress F518_SUF zpalter\"\n              e(title) : \"Linear regression\"\n          e(marginsok) : \"XB default\"\n                e(vce) : \"ols\"\n             e(depvar) : \"F518_SUF\"\n                e(cmd) : \"regress\"\n         e(properties) : \"b V\"\n            e(predict) : \"regres_p\"\n              e(model) : \"ols\"\n          e(estat_cmd) : \"regress_estat\"\n\nmatrices:\n                  e(b) :  1 x 2\n                  e(V) :  2 x 2\n\nfunctions:\n             e(sample)   \n\n\nAnstatt zu versuchen, den Überblick darüber zu behalten, was wo gespeichert wird, finden wir ganz unten in jeder Hilfedatei einen Hinweis wie “summarize stores the following in r():” or “mean stores the following in e()” - entsprechend sehen wir die Ergebnisse in return bzw. ereturn.\n\n\n2.3.2 e() und r() sind getrennte Welten\nNeben dem Prinzip “One Data” folgt Stata auch dem Prinzip “One _-class”. Das bedeutet, dass wir nur den return oder ereturn für den letzten Befehl dieser Klasse sehen können. Wenn wir also reg ausführen und dann eine Reihe von r-Klassen-Aufrufen machen (z.B. su), wird uns der Aufruf von ereturn immer noch die Werte für reg anzeigen. Sobald wir jedoch einen weiteren r-class-Befehl ausführen, verlieren wir den Zugriff auf die Ergebnisse des ersten Befehls.\n\nreg az F200\nsu az\nereturn list\n\n\n\n      Source |       SS           df       MS      Number of obs   =    17,376\n-------------+----------------------------------   F(1, 17374)     =  33637.44\n       Model |  1269310.92         1  1269310.92   Prob > F        =    0.0000\n    Residual |  655608.985    17,374   37.735063   R-squared       =    0.6594\n-------------+----------------------------------   Adj R-squared   =    0.6594\n       Total |   1924919.9    17,375  110.786757   Root MSE        =    6.1429\n\n------------------------------------------------------------------------------\n          az |      Coef.   Std. Err.      t    P>|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n        F200 |   .9897533   .0053965   183.41   0.000     .9791755    1.000331\n       _cons |   3.937849   .1903973    20.68   0.000     3.564651    4.311047\n------------------------------------------------------------------------------\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n          az |     20,012    38.30557    11.75297         10        120\n\n\nscalars:\n                  e(N) =  17376\n               e(df_m) =  1\n               e(df_r) =  17374\n                  e(F) =  33637.43995203968\n                 e(r2) =  .6594097320849045\n               e(rmse) =  6.142887188019294\n                e(mss) =  1269310.915908093\n                e(rss) =  655608.9846442067\n               e(r2_a) =  .6593901286390708\n                 e(ll) =  -56197.03934279057\n               e(ll_0) =  -65554.6676770772\n               e(rank) =  2\n\nmacros:\n            e(cmdline) : \"regress az F200\"\n              e(title) : \"Linear regression\"\n          e(marginsok) : \"XB default\"\n                e(vce) : \"ols\"\n             e(depvar) : \"az\"\n                e(cmd) : \"regress\"\n         e(properties) : \"b V\"\n            e(predict) : \"regres_p\"\n              e(model) : \"ols\"\n          e(estat_cmd) : \"regress_estat\"\n\nmatrices:\n                  e(b) :  1 x 2\n                  e(V) :  2 x 2\n\nfunctions:\n             e(sample)"
  },
  {
    "objectID": "02_loops_fromdata.html#ergebnisse-weiter-verwenden",
    "href": "02_loops_fromdata.html#ergebnisse-weiter-verwenden",
    "title": "2  Schleifen aus Macros",
    "section": "2.4 Ergebnisse weiter verwenden",
    "text": "2.4 Ergebnisse weiter verwenden\nAlle diese Informationen können wir mit einem Makro speichern bzw. weiter verarbeiten.\n\nsu S1\ndis \"Der Mittelwert beträgt: \" r(mean)\n\n\n\nDer Mittelwert beträgt: 1.496602\n\n\n\nsu S1\ndis \"Der Mittelwert beträgt: \" round(r(mean),.01)\n\n\n\nDer Mittelwert beträgt: 1.5\n\n\n\nforeach lvl  of global ausb {\n    dis \"m1202: \" `lvl'\n    su S01 if m1202 == `lvl'\n    dis r(mean)\n}\n\nforeach lvl  of global ausb {\n    qui su S01 if m1202 == `lvl'\n    dis \"Der Frauenanteil in m1202=\" `lvl' \" beträgt: \" round(r(mean)*100,.1) \"%\"\n}\n\n\nforeach lvl  of global ausb {\n    qui su S01 if m1202 == `lvl'\n    glo gend`lvl': display \"Der Frauenanteil in m1202=\" `lvl' \" beträgt: \" round(r(mean)*100,.1) \"%\"\n}\n\n\n2.4.1 Rekursivität\nMacros können auch “recursively” erstellt werden:\n\nglobal x \"\"\nforvalues i = 1/20 {\n    global x $x `i'\n}\nmac list x\n\nx:              1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n\n\n…somit können wir einen global auch zusammenbauen:\n\nglo gend \"\"\nforeach lvl  of global ausb {\n    qui su S01 if m1202 == `lvl'\n    glo gend: display \"${gend}m1202=\" `lvl' \" \" round(r(mean)*100,.1) \"% \"\n}\nmac l gend\n\n\n\n  4. }\n\ngend:           m1202=1 45.6% m1202=2 53% m1202=3 37.8% m1202=4 48.9%\n\n\n\nÜbung"
  },
  {
    "objectID": "02_loops_fromdata.html#mat1",
    "href": "02_loops_fromdata.html#mat1",
    "title": "2  Schleifen aus Macros",
    "section": "2.5 Kennzahlen in einer matrix ablegen",
    "text": "2.5 Kennzahlen in einer matrix ablegen\nMatrizen helfen uns, die ergebnisse in handhabarer Form zu speichern (help matrix). Um eine Tabelle zu bauen benötigen wir einige Matrix-Befehle, weiteres unter help matrix operators\n\neine matrix ausgeben: matrix list matname\neine matrix umbenennen: matrix umbenennen altername neuername\neine matrix oder alle löschen: matrix drop [matlist]\n\n\n\n\n\n \n  \n    Operator \n    Symbol \n  \n \n\n  \n    column join \n    , \n  \n  \n    row join \n    \\\\ \n  \n  \n    transpose \n    ' \n  \n  \n    negation \n    \\- \n  \n\n\n\n\n\n\nmatrix Y1 = 1, 3 \nmat l Y1\n\nY1[1,2]\n    c1  c2\nr1   1   3\n\n\n\nmatrix Y2 = 4\\ 0\nmat l Y2\n\nY2[2,1]\n    c1\nr1   4\nr2   0\n\n\n\nmatrix Y = (2, 1.5 \\ 2.5, 3)\nmat l Y\n\nY[2,2]\n     c1   c2\nr1    2  1.5\nr2  2.5    3\n\n\nTransponieren:\n\nmatrix X2 = (1, 2, 3 \\ 5 , 8 , 9)\nmat l X2 \nmat X3 = X2'\nmat l X3\n\nX2[2,3]\n    c1  c2  c3\nr1   1   2   3\nr2   5   8   9\n\n\n\nX3[3,2]\n    r1  r2\nc1   1   5\nc2   2   8\nc3   3   9\n\n\nMit J(Zeilen,Spalten,Inhalt) können wir eine Matrix mit gleichen Werten besetzen:\n\nmat G0 = J(4,2,0)\nmat l G0\n\nG0[4,2]\n    c1  c2\nr1   0   0\nr2   0   0\nr3   0   0\nr4   0   0\n\n\n\n\n\n\n\n\n\n2.5.1 Namen für Spalten und Zeilen einer matrix\nAber wir können die Zeilennamen einer matrix verändern:\n\nmat colname G0 = var1 var2\nmat list G0\n\n\n\nG0[4,2]\n    var1  var2\nr1     0     0\nr2     0     0\nr3     0     2\nr4     0     0\n\n\nWenn zu wenige Namen angegeben werden, wird der letzte Wert einfach wiederholt:\n\nmat rowname G0 = year result\nmat list X1\n\n\n\nG0[4,2]\n        c1  c2\n  year   0   0\nresult   0   0\nresult   0   2\nresult   0   0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.5.2 matrix erstellen\nDas nutzen wir jetzt um unsere Ergebnisse zu speichern:\n\nlevelsof m1202, loc(ausb)\nforeach lvl  of local ausb {\n    qui su S01 if m1202 == `lvl'\n    \n    // 1. Spalte level von m1202\n    //2.Spalte: Frauenanteil\n    mat G`lvl' = `lvl' ,r(mean)*100 \n}\nmat G = GX1\\GX2\\GX3\\GX4\nmat colname G = m1202 share_w\nmat l G\n\nDamit können wir auch zeilenweise eine matrix befüllen, indem wir mit , mehrere Werte verbinden (row join):\n\nqui levelsof m1202, loc(ausb)\nforeach lvl  of local ausb {\n    qui su zpalter if m1202 == `lvl', det\n    mat A`lvl' = `lvl', r(p25), r(mean), r(p50), r(p75)\n}\nmat A = A1\\A2\\A3\\A4\nmat colname A = m1202 p25 mean median p75\nmat l A\n\n\n\nA[4,5]\n        m1202        p25       mean     median        p75\nr1          1         29  42.627213         46         55\nr1          2         39  47.076531         49         56\nr1          3         41  48.092344         50         56\nr1          4         39  47.760744         49         57\n\n\n\nÜbung"
  },
  {
    "objectID": "02_loops_fromdata.html#labels-behalten",
    "href": "02_loops_fromdata.html#labels-behalten",
    "title": "2  Schleifen aus Macros",
    "section": "2.6 Labels behalten",
    "text": "2.6 Labels behalten\n\n2.6.1 extended macro function für Labels\nIdealerweise würden wir aber gerne nicht nur 1-4 in m1202 behalten, sondern die Labels (Ohne Berufsabschluss) usw. Um Informationen zu Variablen & Labels abzurufen, lernen wir später eine ganze Reihe an extended macro functions kennen, für den Moment reicht uns label (varname) varvalue:\n\nloc v m1202\nlocal vallab1 :    label (`v') 1            // Value label für Wert = 1\ndis \"`vallab1'\"     // display local \"valuelab1\"\n\n\n\nOhne Berufsabschluss\n\n\nIn der Schleife können wir dann lvl entsprechen für label (var) lvl nutzen:\n\nloc lvl = 1\nqui su zpalter if m1202 == `lvl', det\nmat GX = `lvl', r(p25), r(mean), r(p50), r(p75) \nlocal vallab1 :    label (m1202) `lvl' // label aufrufen\n\n\n\n2.6.2 Labels als rowname\nLeider können wir nicht einfach die Labels der Variable in die matrix schreiben. In einer Matrix sind nur Zahlenwerte erlaubt:\n\nmat M = c(2\\\"label\")\n\nr(133);\n\nend of do-file\nr(133);\n\n\nAber wir können das Label als rowname ablegen:\n\nloc lvl = 1\nqui su zpalter if m1202 == `lvl', det\nmat GX = `lvl', r(p25), r(mean), r(p50), r(p75) \nlocal vallab1 :    label (m1202) `lvl' // label aufrufen\nmat rowname GX =  \"`vallab1'\" // in Zeilenname ablegen\nmat l GX\n\n…damit erweitern wir die Schleife von oben:\n\nlevelsof m1202, loc(ausb)\nforeach lvl  of local ausb {\n    qui su zpalter if m1202 == `lvl', det\n    mat GX`lvl' = `lvl', r(p25), r(mean), r(p50), r(p75)\n    \n    local vallab1 :    label (m1202) `lvl'\n    mat rowname GX`lvl' =  \"`vallab1'\"\n}\nmat G = GX1\\GX2\\GX3\\GX4\nmat colname G = m1202 p25 mean median p75\nmat l G\n\n\n\n1 2 3 4\n\n\n\n\n\nG[4,5]\n                  m1202        p25       mean     median        p75\nOhne Beruf~s          1         29  42.627213         46         55\nduale o. s~l          2         39  47.076531         49         56\nAufstiegsf~T          3         41  48.092344         50         56\nFachhochsc~h          4         39  47.760744         49         57"
  },
  {
    "objectID": "02_loops_fromdata.html#von-der-matrix-zum-datensatz",
    "href": "02_loops_fromdata.html#von-der-matrix-zum-datensatz",
    "title": "2  Schleifen aus Macros",
    "section": "2.7 Von der matrix zum Datensatz",
    "text": "2.7 Von der matrix zum Datensatz\nMit xsvmat bzw. dem ado xsvmat können wir eine matrix in einen Datensatz umwandeln. Mit rownames(lab) können wir Zeilennamen in die Variable lab ablegen. Außerdem nutzt xsvmat die neue frame- Funktion, um einen neuen Datensatz zu erstellen.\n\nssc install  xsvmat\n\n\nxsvmat G, names(col) frame(res1) rownames(lab)\nframe change res1\nlist, noobs clean\n\n\n                                                         lab   m1202   p25       mean   median   p75  \n                                        Ohne Berufsabschluss       1    29   42.62721       46    55  \n    duale o. schulische Berufsausbildung/einf.,mittl. Beamte       2    39   47.07653       49    56  \n    Aufstiegsfortbildung (Meister, Techniker, kfm. AFB u.ä.)       3    41   48.09234       50    56  \n            Fachhochschule, Universität/ geh., höhere Beamte       4    39   47.76074       49    57"
  },
  {
    "objectID": "02_loops_fromdata.html#frame",
    "href": "02_loops_fromdata.html#frame",
    "title": "2  Schleifen aus Macros",
    "section": "2.8 frame: mehrere Datensätze in Stata",
    "text": "2.8 frame: mehrere Datensätze in Stata\nDie frame-Option basiert auf einer relativ neuen Funktion in Stata. Seit Version 16 bietet Stata mit den frame-Befehlen auch die Möglichkeit, mehrere Datensätze parallel zu bearbeiten.\n\nmit frame create nameX können wir einen neuen Datensatz mit dem Namen nameX erstellen (der bisherige wird als default bezeichnet)\nmit frame dir bekommen wir eine Übersicht zu den verschiedenen frames der aktuellen Stata-Session\nmit frame change name können wir zwischen den verschiedenen frames hin- und herspringen\n\n\nframe change res1\nframe change default\n\n\nmit frame drop name können wir einen frame wieder löschen:\n\n\nframe drop res1\n\n\n\n\n\nÜbung"
  },
  {
    "objectID": "02_loops_fromdata.html#übungen",
    "href": "02_loops_fromdata.html#übungen",
    "title": "2  Schleifen aus Macros",
    "section": "2.9 Übungen",
    "text": "2.9 Übungen\n\n2.9.1 Übung\n\nZählen Sie die Wörter in den folgenden beiden String-locals\n\n\nloc x1 \"ein sehr langer satz mit vielen wörtern\"\n\nds *wib*\nloc x2 =  r(varlist)\n\n\nWie würde eine Schleife aussehen, die jeweils ein Wort aus den locals nacheinander mit display ausgibt?\n\n\n\n2.9.2 Übung\n\nLaden Sie die Erwerbstätigenbefragung - am besten in der Version ohne Missings in den relevanten Variablen ( \"${data}/BIBBBAuA_2018_suf1.0_clean.dta\", siehe 01_init.do)\nErstellen Sie eine Schleife, welche jeweils das Maximaleinkommen (basierend auf F518_SUF) für die Gemeindegrößenklassen (gkpol) anzeigt.\n\nWie kommen Sie an den Maximalwert für F518_SUF? Verwenden Sie bspw. su oder tabstat zusammen mit return list.\nErstellen Sie mit display eine aussagekräftige Ausgabe\nTesten Sie Ihre Schleifenlogik mit einem local, um anschließend die Schleife “außen herumzubauen”\nWelche Ausprägungen hat gkpol - wie können Sie diese automatisch in eine Schleife überführen?\n\nOptional Passen Sie Ihre Schleife an, sodass für jeden Durchlauf ein global gkX erstellt wird, wobei X für die Ausprägung von gkpol steht und den entsprechenden Maximalwert von F518_SUF für die entsprechende Größenklasse enthält.\n\n\n\n2.9.3 Übung\n\nKopieren Sie die in Übung 2 erstellte Schleife und passen Sie diese so an, dass jeweils die Werte für Min, Mean, Median, Max und N in matrix gesammelt werden.\n\nVerwenden Sie den row join für matrix mit , um jeweils eine Ergebniszeile zu erstellen\n\n\n\n\n2.9.4 Übung\n\nPassen Ihre Schleife von eben mit gkpol so mit Hilfe der Schleife von oben so an, dass die Labels für gkpol als rownames werden legen Sie die Ergebnismatrix in einen frame ab.\n\nNutzen Sie die label (v') 1 extended macro function um das jeweilige Label anzuzeigen\nSetzen Sie das entsprechende Label als rowname\nFügen Sie die einzelnen Ergebnis in eine matrix zusammen\nNutzen Sie xsvmat, um einen frame zu erstellen\nNutzen Sie frame change, um in die Ergebnis-frame zu wechseln (und wieder zurück)"
  },
  {
    "objectID": "03_reg.html#e-und-r-der-regressionsergebnisse",
    "href": "03_reg.html#e-und-r-der-regressionsergebnisse",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.1 e() und r() der Regressionsergebnisse",
    "text": "3.1 e() und r() der Regressionsergebnisse\nDie Koeffizienten und Standardfehler des letzten Modells werden in e() gespeichert:\n\nreg F518_SUF F200\n\n\n\n      Source |       SS           df       MS      Number of obs   =    14,659\n-------------+----------------------------------   F(1, 14657)     =   1370.76\n       Model |  1.3122e+10         1  1.3122e+10   Prob > F        =    0.0000\n    Residual |  1.4031e+11    14,657  9572601.57   R-squared       =    0.0855\n-------------+----------------------------------   Adj R-squared   =    0.0855\n       Total |  1.5343e+11    14,658  10467142.3   Root MSE        =      3094\n\n------------------------------------------------------------------------------\n    F518_SUF |      Coef.   Std. Err.      t    P>|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n        F200 |   109.4473   2.956134    37.02   0.000     103.6529    115.2417\n       _cons |  -344.1221   104.2802    -3.30   0.001    -548.5245   -139.7197\n------------------------------------------------------------------------------\n\n\n\nmat l e(b)\n\n\n\ne(b)[1,2]\n          F200       _cons\ny1   109.44727  -344.12212\n\n\n\n3.1.1 Koeffizienten mit _b / _se aufrufen\nAllerdings gibt es noch eine Abkürzung mit _b[varname] bzw. _se[varname]:\n\ndis \"Der Koeffizient für F200 ist \" _b[F200]\ndis \"Der Standardfehler des Koeffizienten für F200 ist \" _se[F200]\n\n\n\nDer Koeffizient für F200 ist 109.44727\n\nDer Standardfehler des Koeffizienten für F200 ist 2.9561335\n\n\nWir können so auch vorhergesagte Werte berechnen - entweder für spezifische Werte:\n\ndis _b[_cons] + 20 *_b[F200]\nmargins, at(F200 = 20)\n\n\n\n1844.8234\n\n\nAdjusted predictions                            Number of obs     =     14,659\nModel VCE    : OLS\n\nExpression   : Linear prediction, predict()\n\n------------------------------------------------------------------------------\n             |            Delta-method\n             |     Margin   Std. Err.      t    P>|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n       _cons |   1844.823   49.14441    37.54   0.000     1748.494    1941.153\n------------------------------------------------------------------------------\n\n\n…oder für alle Beobachtungen:\n\ngen pred_manual = _b[_cons] + F200 *_b[F200]\npredict pred_auto, xb\ngen diff=  pred_manual - pred_auto\nsu diff\n\n\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n        diff |     17,376           0           0          0          0\n\n\n\n\n3.1.2 Komplette Regressionstabelle\nDie vollständige Regressionstabelle ist aber eine r-Class matrix:\n\nreg F518_SUF F200\nmatlist r(table) \n\n\n\nr(table)[9,2]\n              F200       _cons\n     b   109.44727  -344.12212\n    se   2.9561335   104.28024\n     t   37.023793  -3.2999743\npvalue   6.36e-287   .00096924\n    ll   103.65288  -548.52452\n    ul   115.24167  -139.71973\n    df       14657       14657\n  crit   1.9601259   1.9601259\n eform           0           0"
  },
  {
    "objectID": "03_reg.html#regressionstabellen-als-matrix-speichern-und-anpassen",
    "href": "03_reg.html#regressionstabellen-als-matrix-speichern-und-anpassen",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.2 Regressionstabellen als matrix speichern und anpassen",
    "text": "3.2 Regressionstabellen als matrix speichern und anpassen\nMit ' können wir die Regressionstabelle transponieren:\n\nreg F518_SUF F200\nmat C = r(table)'\nmat l C\n\n\n\nC[2,9]\n                b          se           t      pvalue          ll          ul\n F200   109.44727   2.9561335   37.023793   6.36e-287   103.65288   115.24167\n_cons  -344.12212   104.28024  -3.2999743   .00096924  -548.52452  -139.71973\n\n               df        crit       eform\n F200       14657   1.9601259           0\n_cons       14657   1.9601259           0\n\n\nrownumb hilft, einen Koeffizienten zu suchen:\n\nmat C1 = C[rownumb(C,\"F200\"),1...]\nmat l C1\n\n\n\nC1[1,9]\n              b         se          t     pvalue         ll         ul\nF200  109.44727  2.9561335  37.023793  6.36e-287  103.65288  115.24167\n\n             df       crit      eform\nF200      14657  1.9601259          0"
  },
  {
    "objectID": "03_reg.html#kategoriale-uv",
    "href": "03_reg.html#kategoriale-uv",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.3 kategoriale UV",
    "text": "3.3 kategoriale UV\nDer Koeffizientenname ist etwas komplizierterer Name bei kat. UVs:\n\nreg F518_SUF i.S1 F200\nereturn list\nmat l r(table) \ndis \"Der Koeffizient für S1 = weiblich ist \" _b[2.S1]\n\n\n\nr(table)[9,4]\n                1b.          2.                        \n                S1          S1        F200       _cons\n     b           0  -628.91281    95.08006   464.42184\n    se           .   55.392637   3.2038116   125.90363\n     t           .  -11.353726    29.67717    3.688709\npvalue           .   9.461e-30   5.23e-188   .00022621\n    ll           .  -737.48935   88.800186   217.63489\n    ul           .  -520.33627   101.35993    711.2088\n    df       14656       14656       14656       14656\n  crit   1.9601259   1.9601259   1.9601259   1.9601259\n eform           0           0           0           0\n\nDer Koeffizient für S1 = weiblich ist -628.91281\n\n\nDies müssen wir auch bei der Suche nach einem Koeffizienten berücksichtigen:\n\nmat D = r(table)' // transponieren:\nmat l D\n\n\n                b          se           t      pvalue          ll          ul          df        crit       eform\n1b.S1           0           .           .           .           .           .       14656   1.9601259           0\n 2.S1  -628.91281   55.392637  -11.353726   9.461e-30  -737.48935  -520.33627       14656   1.9601259           0\n F200    95.08006   3.2038116    29.67717   5.23e-188   88.800186   101.35993       14656   1.9601259           0\n_cons   464.42184   125.90363    3.688709   .00022621   217.63489    711.2088       14656   1.9601259           0"
  },
  {
    "objectID": "03_reg.html#als-datensatz-ablegen",
    "href": "03_reg.html#als-datensatz-ablegen",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.4 Als Datensatz ablegen:",
    "text": "3.4 Als Datensatz ablegen:\nAuch hier können wir dann mit xsvmat die Matrix in einen Datensatz umformatieren:\n\ncap frame drop regres1\nxsvmat D,  names(col) rownames(coef) frame(regres1)\nframe change regres1\n\nlist, noobs clean\n\n\n coef           b         se           t     pvalue          ll          ul      df       crit   eform  \n1b.S1           0          .           .          .           .           .   14656   1.960126       0  \n 2.S1   -628.9128   55.39264   -11.35373   9.46e-30   -737.4893   -520.3362   14656   1.960126       0  \n F200    95.08006   3.203812    29.67717          0    88.80019    101.3599   14656   1.960126       0  \n_cons    464.4218   125.9036    3.688709   .0002262    217.6349    711.2088   14656   1.960126       0"
  },
  {
    "objectID": "03_reg.html#weitere-infos-aus-e",
    "href": "03_reg.html#weitere-infos-aus-e",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.5 weitere Infos aus e()",
    "text": "3.5 weitere Infos aus e()\nIn ereturn list oben sehen wir, dass e(cmdline) den reg-Befehl enthält:\n\n reg F518_SUF i.S1 F200\ndis \"`e(cmdline)'\"\n\n\n\nregress F518_SUF i.S1 F200\n\n\nDiese Information können wir mit in den Ergebnis-frame nehmen. globals bleiben nehmen in der Session erhalten, auch wenn wir zwischen frames wechseln:\n\ngen mo = \"`e(cmdline)'\"\nlist, noobs clean\n\n\n coef           b         se           t     pvalue          ll          ul      df       crit   eform                           mo  \n1b.S1           0          .           .          .           .           .   14656   1.960126       0   regress F518_SUF i.S1 F200  \n 2.S1   -628.9128   55.39264   -11.35373   9.46e-30   -737.4893   -520.3362   14656   1.960126       0   regress F518_SUF i.S1 F200  \n F200    95.08006   3.203812    29.67717          0    88.80019    101.3599   14656   1.960126       0   regress F518_SUF i.S1 F200  \n_cons    464.4218   125.9036    3.688709   .0002262    217.6349    711.2088   14656   1.960126       0   regress F518_SUF i.S1 F200  \n\nDiese Beschreibung ist natürlich alles andere als ideal. Im nächsten Kapitel werden wir einige Möglichkeiten kennenlernen, da etwas zu ändern.\n\nÜbung\n\n\n3.5.1 e(sample)\ne(sample) ist eine e()-Class Funktion, welche die in einem Modell berücksichtigten Fälle zu markieren:\n\nquietly reg F518_SUF i.S1 F200\ngen smpl = e(sample)\ntab sampl\n\n\n\n       smpl |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          0 |      5,353       26.75       26.75\n          1 |     14,659       73.25      100.00\n------------+-----------------------------------\n      Total |     20,012      100.00\n\n\nSo können wir bspw. sehen, wo die Missings liegen:\n\nmdesc  F518_SUF S1 F200 if smpl == 0\n\n\nquietly{\n  use \"./data/BIBBBAuA_2018_suf1.0_clean.dta\", replace \n  reg F518_SUF i.S1 F200\n  gen smpl = e(sample)\n}\nmdesc  F518_SUF S1 F200 if smpl == 0\n\n    Variable    |     Missing          Total     Percent Missing\n----------------+-----------------------------------------------\n       F518_SUF |       3,377          5,353          63.09\n             S1 |           0          5,353           0.00\n           F200 |       2,636          5,353          49.24\n----------------+-----------------------------------------------"
  },
  {
    "objectID": "03_reg.html#reg-schrittweise-aufbauen",
    "href": "03_reg.html#reg-schrittweise-aufbauen",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.6 reg schrittweise aufbauen",
    "text": "3.6 reg schrittweise aufbauen\n\nglo mod1 i.S1 az i.m1202 zpalter i.Mig\nqui regress F518_SUF ${mod1}\ngen smpl2 = e(sample)\n\nlocal len2: word count ${mod1}\nforvalues i = 1(1)`len2' {\n    loc word: word `i' of ${mod1}\n    dis \"Modell Nr\" `i' \": mit `word'\"\n    loc x `x' `word'\n    qui reg F518_SUF `x' if smpl2 == 1\n    est store m`i'\n}\n\nest dir\nesttab m*, b se  // ssc install esttab\n\n\n\nModell Nr1: mit i.S1\nModell Nr2: mit az\nModell Nr3: mit i.m1202\nModell Nr4: mit zpalter\nModell Nr5: mit i.Mig\n\n\n----------------------------------------------------------------\n        name | command      depvar       npar  title \n-------------+--------------------------------------------------\n          m1 | regress      F518_SUF        3  Linear regression\n          m2 | regress      F518_SUF        4  Linear regression\n          m3 | regress      F518_SUF        8  Linear regression\n          m4 | regress      F518_SUF        9  Linear regression\n          m5 | regress      F518_SUF       12  Linear regression\n----------------------------------------------------------------\n\n\n--------------------------------------------------------------------------------------------\n                      (1)             (2)             (3)             (4)             (5)   \n                 F518_SUF        F518_SUF        F518_SUF        F518_SUF        F518_SUF   \n--------------------------------------------------------------------------------------------\n1.S1                    0               0               0               0               0   \n                      (.)             (.)             (.)             (.)             (.)   \n\n2.S1              -1434.1***       -683.3***       -725.7***       -755.7***       -756.4***\n                  (53.94)         (55.19)         (53.65)         (53.50)         (53.51)   \n\naz                                  91.74***        83.46***        84.05***        83.99***\n                                  (2.376)         (2.323)         (2.315)         (2.316)   \n\n1.m1202                                                 0               0               0   \n                                                      (.)             (.)             (.)   \n\n2.m1202                                             384.1***        261.9*          250.9*  \n                                                  (114.5)         (114.6)         (115.2)   \n\n3.m1202                                             898.1***        737.2***        724.5***\n                                                  (137.7)         (137.9)         (138.5)   \n\n4.m1202                                            2074.7***       1933.3***       1924.7***\n                                                  (116.0)         (116.2)         (116.7)   \n\nzpalter                                                             25.41***        25.27***\n                                                                  (2.200)         (2.210)   \n\n0.Mig                                                                                   0   \n                                                                                      (.)   \n\n1.Mig                                                                               10.65   \n                                                                                  (93.55)   \n\n2.Mig                                                                              -175.8   \n                                                                                  (146.9)   \n\n_cons              4236.3***        359.5***       -376.7**       -1447.4***      -1423.9***\n                  (37.72)         (106.7)         (141.0)         (168.3)         (171.2)   \n--------------------------------------------------------------------------------------------\nN                   16518           16518           16518           16518           16518   \n--------------------------------------------------------------------------------------------\nStandard errors in parentheses\n* p<0.05, ** p<0.01, *** p<0.001\n\n\n\nÜbung"
  },
  {
    "objectID": "03_reg.html#übungen",
    "href": "03_reg.html#übungen",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.7 Übungen",
    "text": "3.7 Übungen\n\n3.7.1 Übung\nErstellen Sie folgendes Regressionsmodell:\n\nreg az i.mig01 zpalter\n\n(In mig01 steht dann 0 für keinen Migrationshintergrund und 1 für Migrationshintergrund - siehe auch 01_init.do)\n\nErstellen Sie jeweils einen display-Befehl, der den Koeffizienten und Standardfehler für mig01 und zpalter mit einer Aussagekräftigen Nachricht ausgibt\nWie würde das als Schleife über die Koeffizienten aussehen?\nExtrahieren Sie die Regressionstabelle als matrix und legen sie diese als frame ab.\nErstellen Sie zusätzlich eine Spalte mit dem Regressionsbefehl.\n\n\n\n3.7.2 Übung\nBauen Sie folgendes Modell Schritt für Schritt auf und lassen Sie sich die Tabelle mit esttab ausgeben:\n\nreg az i.S1 zpalter c.zpalter#c.zpalter i.gkpol i.F1604 i.F1604##i.S1"
  },
  {
    "objectID": "03_reg.html#anhang",
    "href": "03_reg.html#anhang",
    "title": "3  Regressionsergebnisse weiterverarbeiten",
    "section": "3.8 Anhang",
    "text": "3.8 Anhang\n\n3.8.1 statsby\n\nstatsby _b _se, by(Bula) noisily: ///\n    regress F518_SUF c.F200##c.F200 i.m1202 i.S1\n\n\n\n3.8.2 reg-Ergebnisse für Modelle sammeln: Schleife\nWir können mit den matrix-Befehlen auch eine Schleife bauen, welche eine Reihe an Regressionsmodellen schätzt und bei jedem Durchlauf einen zusätzlichen Term hinzunimmt. Wir interessieren uns aber nur, dafür wie sich der Koeffizient für das Geschlecht (S1 == 2) entwickelt mit jedem neuen Modell. Mit den matrix-Befehlen können wir dieser herausfiltern.\n\nlocal predictors i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter // UV-Liste\nlocal r = 1 // Zähler \nloc uv      // uv rücksetzen (zur sicherheit)\nforeach v of local predictors {\n  local uv `uv' `v'\n    qui regress F518_SUF `uv'\n    mat D = r(table)'                       // reg-tabelle transponieren & speichern \n    mat D2 = D[rownumb(D,\"2.S1\"),1...]      // Koeffizient für S1=2 behalten\n    \n    if (`r' == 1) mat R = D2                // im ersten Durchlauf R erstellen\n    if (`r' != 1) mat R = R\\D2              // danach: D2 an R anfügen\n        \n    loc ++r // Zähler + 1\n}\nmat l R\n\n\nR[6,9]\n               b          se           t      pvalue          ll          ul          df        crit       eform\n2.S1  -1431.8093   53.630001  -26.697917   8.52e-154  -1536.9298  -1326.6888       16633   1.9601066           0\n2.S1  -628.91281   55.392637  -11.353726   9.461e-30  -737.48935  -520.33627       14656   1.9601259           0\n2.S1   -661.6656   55.679749  -11.883416   2.034e-32  -770.80492  -552.52628       14655   1.9601259           0\n2.S1  -664.94219   53.793012  -12.361126   6.336e-35  -770.38328  -559.50111       14633   1.9601261           0\n2.S1  -700.71303   54.028438  -12.969337   2.975e-38  -806.61563  -594.81043       14552    1.960127           0\n2.S1  -717.33567   54.061055  -13.268991   5.977e-40  -823.30221  -611.36914       14551    1.960127           0\n\nWie wissen wir jetzt, für was kontrolliert wurde?\nWir nutzen den Zähler, um ein global mit der Zählernummer zu erstellen und eine Zeile in die matrix einzufügen:\n\nlocal predictors i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter\nlocal r = 1 // Zähler \nloc uv      // uv rücksetzen (zur sicherheit)\nforeach v of local predictors {\n    local uv `uv' `v'\n    qui regress F518_SUF `uv'\n    mat D = r(table)'                       // reg-tabelle transponieren & speichern \n    mat D2 = D[rownumb(D,\"2.S1\"),1...]      // Koeffizient für S1=2 behalten\n    \n    mat M = `r'\n    mat colname M = mod\n    \n    if (`r' == 1) mat R = D2 , M            // ,r -> zähler an Koeffizientzeile anfügen\n    if (`r' != 1) mat R = R\\(D2 , M)\n    glo cmd`r' = \"`e(cmdline)'\"\n    loc ++r // Zähler + 1\n}\nmat l R\n\n\nR[6,10]\n               b          se           t      pvalue          ll          ul          df        crit       eform         mod\n2.S1  -1431.8093   53.630001  -26.697917   8.52e-154  -1536.9298  -1326.6888       16633   1.9601066           0           1\n2.S1  -628.91281   55.392637  -11.353726   9.461e-30  -737.48935  -520.33627       14656   1.9601259           0           2\n2.S1   -661.6656   55.679749  -11.883416   2.034e-32  -770.80492  -552.52628       14655   1.9601259           0           3\n2.S1  -664.94219   53.793012  -12.361126   6.336e-35  -770.38328  -559.50111       14633   1.9601261           0           4\n2.S1  -700.71303   54.028438  -12.969337   2.975e-38  -806.61563  -594.81043       14552    1.960127           0           5\n2.S1  -717.33567   54.061055  -13.268991   5.977e-40  -823.30221  -611.36914       14551    1.960127           0           6\n\nDiese matrix R schicken wir jetzt in einen frame:\n\ncap frame drop rmods\nxsvmat R,  names(col) rownames(coef) frame(rmods)\nframe change rmods\n\nlist, noobs clean\n\n\ncoef           b         se           t     pvalue          ll          ul      df       crit   eform   mod  \n2.S1   -1431.809      53.63   -26.69792          0    -1536.93   -1326.689   16633   1.960107       0     1  \n2.S1   -628.9128   55.39264   -11.35373   9.46e-30   -737.4893   -520.3362   14656   1.960126       0     2  \n2.S1   -661.6656   55.67975   -11.88342   2.03e-32   -770.8049   -552.5263   14655   1.960126       0     3  \n2.S1   -664.9422   53.79301   -12.36113   6.34e-35   -770.3833   -559.5011   14633   1.960126       0     4  \n2.S1    -700.713   54.02844   -12.96934   2.97e-38   -806.6156   -594.8104   14552   1.960127       0     5  \n2.S1   -717.3357   54.06105   -13.26899          0   -823.3022   -611.3691   14551   1.960127       0     6  \n\nJetzt wissen zwar schon mal, aus welchem Modell der Koeffizient jeweils kommt (basierend auf mod). Eigentlich würden das aber gerne labeln. Dazu können wir jetzt auf die globals zurückgreifen - mit all globals können wir nach ihnen suchen:\n\nglobal allglo:  all globals \"cmd*\"\nmac l allglo\nallglo:         cmd6 cmd5 cmd4 cmd3 cmd2 cmd1\n\n\nmac l cmd1\ncmd1:           regress F518_SUF i.S1\n\nJetzt können wir mit einer Schleife die Spalte mod labeln. Mit label define .... können Wertelabels erstellt werden - mit der Option ,modify können wir das auch schrittweise verändern. Außerdem können wir einen kleinen Trick nutzen, um innerhalb der Schleife auf das global mit einer bestimmten Zahl zuzugreifen:\n\nlevelsof mod, loc(mnrs)\n  foreach m of local mnrs {\n    lab def mod_lab `m' \"${cmd`m'}\", modify // value label verändern \n  }\nlab val mod mod_lab\n\nlist, noobs clean\n\n\n    coef           b         se           t     pvalue          ll          ul      df       crit   eform                                                                              mod  \n    2.S1   -1431.809      53.63   -26.69792          0    -1536.93   -1326.689   16633   1.960107       0                                                            regress F518_SUF i.S1  \n    2.S1   -628.9128   55.39264   -11.35373   9.46e-30   -737.4893   -520.3362   14656   1.960126       0                                                     regress F518_SUF i.S1 c.F200  \n    2.S1   -661.6656   55.67975   -11.88342   2.03e-32   -770.8049   -552.5263   14655   1.960126       0                                       regress F518_SUF i.S1 c.F200 c.F200#c.F200  \n    2.S1   -664.9422   53.79301   -12.36113   6.34e-35   -770.3833   -559.5011   14633   1.960126       0                               regress F518_SUF i.S1 c.F200 c.F200#c.F200 i.m1202  \n    2.S1    -700.713   54.02844   -12.96934   2.97e-38   -806.6156   -594.8104   14552   1.960127       0                       regress F518_SUF i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter  \n    2.S1   -717.3357   54.06105   -13.26899          0   -823.3022   -611.3691   14551   1.960127       0   regress F518_SUF i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter  \n\nDaraus können wir beispielsweise einen Koeffizientenplot erstellen:\n\ngraph twoway ///\n    (rcap ll ul mod,horizontal lcolor(\"57 65 101\") ) /// Konfidenzintervalle\n    (scatter mod b,  mcolor(\"177 147 74\") )  , /// Punktschätzer\n    graphregion(fcolor(white)) /// Hintergundfarbe (außerhalb des eigentlichen Plots)\n    ylabel(, valuelabel angle(0) labsize(tiny)) ///\n    legend(off) ///\n    xtitle(\"Einkommen (W) vs. Einkommen (M)\") /// Achsentitel\n    ytitle(\"\") /// \n    title(\"Titel\")  ///\n    subtitle(\"Untertitel\") ///\n    caption(\"{it:Quelle: Erwerbstätigenbefragung 2018}\", size(8pt) position(5) ring(5) )\n\n\n\nError in knitr::include_graphics(\"./graph/Regplot.png\"): Cannot find the file(s): \"./graph/Regplot.png\"\n\n\nDiese labels sind natürlich alles andere als ideal. Im nächsten Kapitel werden wir einige Möglichkeiten kennenlernen, da etwas zu ändern."
  },
  {
    "objectID": "04_labels_variab.html",
    "href": "04_labels_variab.html",
    "title": "4  Label- und Variablenfunktionen",
    "section": "",
    "text": "Inspiriert von der UCLA einige Beispielstrings:"
  },
  {
    "objectID": "04_labels_variab.html#stringfunktionen",
    "href": "04_labels_variab.html#stringfunktionen",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.1 Stringfunktionen",
    "text": "4.1 Stringfunktionen\nhelp string functions\n\ngen x1 = substr(add,5,10)   //  substring von add -> Zeichen 5-10\ngen x2 = wordcount(add)       // Worte zählen\ngen x3 = word(add,5)      // 5. Wort\ngen x4 = upper(add)         // alles groß\ngen x5 = lower(add)     // alles klein\ngen x6 = proper(add)    // jeweiles erster Buchstabe eines Wortes groß\ngen x7 = trim(add)      // Leerzeichen am Ende und Beginn raus\ngen x8 = strlen(add)    // Anzahl der Zeichen in add\n\nAllerdings sind diese Funktionen auf ASCII-Zeichen ausgelegt - einfach gesagt: Umlaute, ß usw. bereiten Probleme. Daher gibt es eine Erweiterung mit usubstr, ustrupper(), ustrlower() usw. - mehr dazu jeweils in der Hilfe.\nDer Weg zur passenden regex string-Funktion ist leider oft von vielen Versuchen begleitet, am einfachsten testet man mit display. So zeigt sich hier bspw., dass proper() hier “ß” und “ü” als Wortende/-beginn (mis-)versteht:\n\ndisplay proper(\"Regensburger Straße 100, 90478 nüRnberg germany\")\n\n\n\nRegensburger StraßE 100, 90478 NüRnberg Germany\n\n\n…in der Hilfe finden wir ustrtitle:\n\ndisplay ustrtitle(\"Regensburger Straße 100, 90478 nüRnberg germany\")\n\n\nRegensburger Straße 100, 90478 Nürnberg Germany\n\nHier wenig hilfreich, aber häufig eine gute Abkürzung: split Mit parse() können wir einen Trenner angeben.\n\nsplit add, parse(\" \") gen(t)\n\n\nÜbung\n\nTipp: real() ist deutlich schneller und unkomplizierter als destring\n\nclear all\ninput str1 x1\n\"2\"\n\"3\"\n\"5\"\n\"23\"\n\"21\"\n\"2\"\n\"--\"\n\"2\"\nend\n\ngen num = real(x1)\nlist\ndestring(x1), gen(num2)\n\n            x1\n  1. \"2\"\n  2. \"3\"\n  3. \"5\"\n  4. \"23\"\n  5. \"21\"\n  6. \"2\"\n  7. \"--\"\n  8. \"2\"\n  9. end\n\n(1 missing value generated)\n\n     +----------+\n     | x1   num |\n     |----------|\n  1. |  2     2 |\n  2. |  3     3 |\n  3. |  5     5 |\n  4. |  2     2 |\n  5. |  2     2 |\n     |----------|\n  6. |  2     2 |\n  7. |  -     . |\n  8. |  2     2 |\n     +----------+\n\nx1: contains nonnumeric characters; no generate"
  },
  {
    "objectID": "04_labels_variab.html#arbeiten-mit-regular-expressions",
    "href": "04_labels_variab.html#arbeiten-mit-regular-expressions",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.2 Arbeiten mit “Regular Expressions”",
    "text": "4.2 Arbeiten mit “Regular Expressions”\n“regular expressions” oder “regex” sind eine flexible Methode, strings (also Textinhalte) zu durchsuchen. Dabei suchen wir nach Mustern anstelle eines exakten matchings.\nIn Stata können wir regex für Variablen, aber auch für macros und Labels verwenden. regex sind aber nicht immer die (einfachste) Lösung und oft werden die Befehle sehr unübersichtlich. Daher hier nur ein kurzer Überblick.\nDie drei Hauptfunktionen in Stata finden wir unter help regex:\n\nregexm(s,re) allows you to search for the string described in your regular expressions. It evaluates to 1 if the string matches the expression.\n\n\nregexs(n) returns the nth substring within an expression matched by regexm (hence, regexm must always be run before regexs).\n\n\nregexr(s1,re,s2) searches for re within the string (s1) and replaces the matching portion with a new string (s2).\n\nAllerdings sind diese Funktionen auf ASCII-Zeichen ausgelegt - einfach gesagt: Umlaute, ß usw. bereiten Probleme. Daher gibt es eine Erweiterung mit ustrregexm, ustrregexs, ustrregexrf und ustrregexra. Auf die konzentrieren wir uns hier.\n\n4.2.1 regex (Grund-)Regeln\nregex basieren auf einer Reihe an Zeichen, mit Hilfe derer wir strings durchsuchen können:\n\n\\d matcht eine Zahl\n\\w matcht “alphanumeric characters” (Buchstaben & Zahlen)\n\\s matcht ein Leerzeichen\n^ “matche Ausdruck am Anfang des strings”\n$ “matche Ausdruck am Ende des strings”\n- lässt eine range zu: a-z, 0-9, 5-8, F-M etc.\n. bedeutet “matche irgendein Zeichen”\n\\ ist ein “escape character” für Zeichen, die ansonsten als regex-Operator verstanden würden\n| oder-Operator\n[] use in matching, such as [a-zA-Z0-9] for all alphanumeric characters\n() darin angegebene Werte können wir mit ustrregexs extrahieren\n* “matche 0 oder öfter” für den vorhergehenden Ausdruck\n+ “matche 1 oder öfter” für den vorhergehenden Ausdruck\n\n\n\n4.2.2 Beispiele\nInspiriert von der UCLA einige Beispielstrings:\n\nclear all\ninput str60 add\n\"4905 Lakeway Drive, College Station, Texas 77845 USA\"\n\"673 Jasmine Street, Los Angeles, CA 90024\"\n\"2376 First street, San Diego, CA 90126\"\n\"6 West Central St, Tempe AZ 80068\"\n\"1234 Main St. Cambridge, MA 01238-1234\"\n\"Robert-Schuman-Platz 3, 53175 Bonn GERMANY\"\n\"Regensburger Straße 100, 90478 Nürnberg Germany\"\n\"Ammerländer Heerstraße 114-118, 26129 Oldenburg GERMANY\"\nend\n\n\ngen d = ustrregexm(add, \"GERMANY|Germany\")\n\nDas m in ustrregexm steht für match. Mit ustrregexm können wir nach Zeichenketten suchen. Wenn sie gefunden wird, wird eine 1 zurückzugeben, andernfalls 0. Hier suchen wir nach “entweder GERMANY oder Germany”.\nWir können aber auch den gefundenen Inhalt extrahieren. Bei Übereinstimmungen werden die matches gespeichert, darauf können wir mit ustrregexs zurückgreifen:\n\ngen d2 = ustrregexs(0) if ustrregexm(add, \"GERMANY|Germany\")\n\ns steht für subexpressions (oder “tokens”). Token 0 enthält alle übereinstimmenden Muster. Wird eine Zeichenkette mehrfach gefunden, dann enthält Token 0 alle Übereinstimmungen, Token 1 die erste, Token 2 die zweite und so weiter.\nustrregexrf und ustrregexra helfen uns schließlich, Inhalte zu ersetzen. rf bzw. ra stehen dabei für “replace first” bzw. “replace all”. ustrregexrf ersetzt also nur den ersten match, ustrregexra hingegen alle.\nBasierend auf den Regeln von oben ergeben diese beiden Befehle unterschiedliche Ergebnisse:\n\ngen s1 = ustrregexra(add, \"street\",   \"!\")\ngen s2 = ustrregexra(add, \"[street]\", \"!\")\n\nIn s1 wurden alle matches “street” gelöscht und durch ! ersetzt. In s2 wurden alle matches von “s”,“t”,“r”,“e” und “t” gelöscht und durch ! ersetzt.\nWeitere Beispiele für ersetzen mit regex-Regelausdrücken - siehe DoFile:\n\ngen z1 =  ustrregexra(add, \"\\w\", \"\") // alle alphanumeric ersetzen\ngen z2 = ustrregexra(add, \"\\W\", \"\") // alle nicht-alphanumeric ersetzen\ngen z3 =  ustrregexra(add, \"\\d\", \"\") // alle Zahlen ersetzen \ngen z4 = ustrregexra(add, \"\\D\", \"\") // alle nicht-Zahlen ersetzen \ngen z5 = ustrregexra(add, \".+,\", \"\") // alles vor dem Komma ersetzen\ngen z6 = ustrregexra(add, \",.+\", \"\") // alles nach dem Komma ersetzen\n\nNach Zahlen suchen:\n\ngen r1 = ustrregexs(0) if ustrregexm(add, \"\\d\")  // Zahl\ngen r2 = ustrregexs(0) if ustrregexm(add, \"\\d+\") // Zahlenfolge\ngen r3 = ustrregexs(0) if ustrregexm(add, \"(\\d{5})\") // 5-stellige Zahl\ngen r4 = ustrregexs(0) if ustrregexm(add, \"^(\\d+)\") // Zahlenfolge am Anfang\ngen r5 = ustrregexs(0) if ustrregexm(add, \"(\\d+).*(\\d+)\") // Zahlenfolgen und alles was dazwischen kommt \ngen r6 = ustrregexs(0) if ustrregexm(r5, \"(\\d+)$\") // Zahlenfolge am Ende -> aus r5!\n\n\n\n4.2.3 Weiterführende Links\nHier findet sich ein sehr gutes “Cheatsheet” zu den gebräuchlichsten regex. Das zugehörige Tutorial ist ebenfalls sehr lesenswert. Die Übersicht der UCLA bietet auch nochmal einige Hinweise - allerdings auf Basis der ASCII-basierten Befehle. Stata Hilfe Hier findet sich ein weiteres hilfreiches Tutorial\n\nÜbung"
  },
  {
    "objectID": "04_labels_variab.html#labfuns",
    "href": "04_labels_variab.html#labfuns",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.3 Label bearbeiten",
    "text": "4.3 Label bearbeiten\nUm Informationen zu Variablen & Labels abzurufen, stehen eine ganze Reihe an extended macro functions zur Verfügung:\n\nloc v m1202\n\nlocal vartype:     type `v'                   // Variablen \"storage type\" (byte etc)\nlocal varlab:      variable label `v' // variable label\nlocal vallabname:  value label `v'    // Name des value label\nlocal vallab1 :    label (`v') 1            // Value label für Wert = 1\n\nDie so erstellten locals können wir dann in der bekannten Methode wieder darstellen:\n\ndi \"`vartype'\"     // display local \"vartype\"\ndi \"`varlab'\"      // display local \"varlabel\"\ndi \"`vallabname'\"  // display local \"valuelabname\"\ndi \"`vallab1'\"     // display local \"valuelab1\"\n\nWir können die Labels und Eigenschaften von `v’ auch in einem Schritt anzeigen lassen, die Syntax sieht aber etwas eigenwillig aus:\n\nloc v m1202\ndi \"`: type `v''\"                  // \"storage type\" (byte etc) der Variable\ndi \"`: variable label `v''\"  // variable label\ndi \"`: value label `v''\"         // Name des value label\ndi \"`: label (`v') 1'\"         // Value label für Wert = 1\n\nDamit können wir bspw. ein Variable Label kürzen:\n\nlocal longlabel: var label m1202        // variable label für variable m1202 suchen\nlocal shortlabel = substr(\"`longlabel'\",1,10) // verändern mit string Funktion \nlabel var m1202 \"`shortlabel'\"         // anwenden\n\nUm an die Value Labels zu kommen, braucht es etwas mehr:\n\nlocal lblname: value label m1202    // value labels für variable m1202 suchen\ncap label drop `lblname'_n          //neuen namen droppen zur Sicherheit\nlabel copy `lblname' `lblname'_n    // value labelbook kopieren\n\nlocal lab1: label (m1202) 2 // value label für Wert = 2 aufrufen\nloc lab2 = upper(\"`lab1'\")      // dieses value labels verändern\nlabel define `lblname'_n `lvl' \"`lab2'\", modify // in neues value labelbook einfügen\n\nlabelbook `lblname' `lblname'_n // vergleich alt vs neu\n\nMit label copy oldname newname, local lblname: value label var und local lab1: label (var) level können wir auch value-Labels bearbeiten:\n\nloc v m1202 \n\nlocal lblname: value label `v'       // value label aufrufen\ncap label drop `lblname'_n           // neuen Namen zur Sicherheit droppen\nlabel copy `lblname' `lblname'_n     // kopieren\nlevelsof `v', loc(x)                 // Werte für die Variable aufrufen\n\nforeach lvl of local x {\n    local lab1: label (`v') `lvl'     // Value label Variable v bei Level lvl\n    loc lab2 = substr(\"`lab1'\",1,8)         // kürzen \n    \n    label define `lblname'_n `lvl' \"`lab2'\", modify // im neuen value label ändern\n  }\n  \nlab val `v' `lblname'_n             // anwenden\n\n\nÜbung 2"
  },
  {
    "objectID": "04_labels_variab.html#abgleiche",
    "href": "04_labels_variab.html#abgleiche",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.4 Abgleiche",
    "text": "4.4 Abgleiche\nExistiert eine Variable?\n\ncapture confirm  variable lm02\nif !_rc dis \"ja\"\nif _rc  dis \"nein\"\n\nIst variable numerisch?\n\ncapture confirm numeric variable az\nif !_rc dis \"ja\"\nif _rc  dis \"nein\"\n\n\n\nja\n\n\nhelp data_types"
  },
  {
    "objectID": "04_labels_variab.html#valsearch",
    "href": "04_labels_variab.html#valsearch",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.5 wo kommt überall -4 vor?",
    "text": "4.5 wo kommt überall -4 vor?\n\nquietly ds\nlocal varlist1 `r(varlist)'\n*display \"`varlist1'\"\nforeach v of varlist1 {\n  qui count if `v' == -4\n  if r(N) > 0 display \"`v'\"\n}\n\n* oder direkt:\nforeach v of varlist * {\n  qui count if `v' == -4\n  if r(N) > 0 display \"`v'\"\n}\n\n\nÜbung"
  },
  {
    "objectID": "04_labels_variab.html#übungen",
    "href": "04_labels_variab.html#übungen",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.6 Übungen",
    "text": "4.6 Übungen\n\n4.6.1 Übung\n\nVerwenden Sie mit input die Adressdaten von oben\nWie kommen Sie jeweils an das vorletzte Wort aus der Adressliste?\nExtrahieren Sie die zehn letzten Zeichen aus add, aber lassen die drei letzten Zeichen weg. (“Zeichen 10 bis 4 von hinten her gezählt”).\n\n\n\n4.6.2 Übung\n\nLaden Sie den regex.dta:\nuse \"https://github.com/filius23/StataProgBIBB/raw/main/docs/regex1.dta\", clear und teilen Sie die Informationen aus address in 4 Variablen auf: Hausnummer (erste Zahl), Straße, PLZ, Region\n\nWandeln Sie alle Einträge in Großbuchstaben um\nVerwenden Sie split mit geeignetem parse()-Argument, um zwischen Hausnummer & Straße und PLZ & Region zu trennen.\nWie können Sie jetzt die Zahlen vom Text trennen? (Tipp: Suchen Sie erst nach den Zahlen. Tipp2: Was wollen wir dann in den Textvariablen nicht mehr?)\nLöschen Sie ggf. Leerzeichen zu Beginn und am Ende der Variablen\n\n\n\n\n4.6.3 Übung\n\nLaden Sie der Erwerbstätigenbefragung\nKürzen die die variable labels für alle Variablen mit “wissensintensiver Beruf” im Label (d *wib*)\n\nErsetzen Sie “wissensintensiver Beruf” in den variable labels mit “wib”.\nSpielen Sie die Routine erst für eine Variable durch: welche Label-Befehle brauchen Sie?\nDenken Sie an foreach ... of varlist und die Möglichkeit, wildcards zu verwenden. Alternativ hilft evtl. auch ds mit Wildcards\n\n\nSo können Sie überpürfen, ob das geklappt hat:\n\nd *wib*\n\n\nBearbeiten Sie das value label für nuts2 - nutzen Sie dafür die regex und string-Funktionen von oben\n\nLöschen Sie “Statistische” aus den den value labels und ersetzen Sie “Direktionsbezirk” durch “Bezirk”:\n\n\n\ntab nuts2\n\n\nKehren Sie die Codierung vom m1202 um: gen m1202_n = 10 - m1202 und passen Sie die value labels entsprechend an die neue Codierung an.\n\nTipp: auch die value labels müssen dann jeweils 10 - x genommen werden.\n\n\nFür alle, die schon fertig sind:\n\nWie könnten Sie automatisiert den Variable label für die Muttersprachenvariablen (F1606_*) kürzen, sodass statt “Muttersprache:” nur noch “MSpr” im label steht?\n\n\n\n4.6.4 Übung\n\nIn welchen Variablen aus der Erwerbstätigenbefragung kommt der der Wert -9 vor?\nFüttern Sie diese Information in mvdecode, um die Missings zu überschreiben.\n\nSammeln Sie die Information, welche Variablen -9 enthalten (Stichwort rekursive macro-Definition)\nErstellen Sie einen mvdecode-Befehle, welcher die Information aufnimmt und in allen gefundenen Variablen -9 durch . ersetzt."
  },
  {
    "objectID": "04_labels_variab.html#anhang",
    "href": "04_labels_variab.html#anhang",
    "title": "4  Label- und Variablenfunktionen",
    "section": "4.7 Anhang",
    "text": "4.7 Anhang\nVariablen mit bestimmten Eigenschaften identifizieren in ein macro\n\nds, has(type byte)\nloc bytevars `r(varlist)'\n\nforeach v of local bytevars {\n    rename `v' b_`v'\n}"
  },
  {
    "objectID": "05_Daten.html#dir---alles-einlesen",
    "href": "05_Daten.html#dir---alles-einlesen",
    "title": "5  Dateien- und DoFile-Verwaltung",
    "section": "5.1 dir - alles einlesen",
    "text": "5.1 dir - alles einlesen\n\nglo pfad \"D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataProgBIBB\\projekt\"\n\nglobal filelist: dir . files \"*.*\"          //Lister aller Dateien\nmac l filelist\n\nglobal dtalist: dir \"${pfad}\" files \"baua*.dta\" // Liste aller .dta-Dateien\nmac l dtalist\n\n\nloc usefile `: word 1 of ${dtalist}'                // erster Eintrag aus der Liste\ndis \"${pfad}/`usefile'\"\n\nuse \"${pfad}/`usefile'\", clear                      // dta laden\nloc n_datasets : list sizeof global(dtalist)        // anzahl  dta einträge\nforeach i of numlist 2(1)`n_datasets' {\n    loc appendfile `: word `i' of ${dtalist}'       // name aus list aufrufen\n    qui append using \"${pfad}/`appendfile'\"          // append\n    dis \"`appendfile' appended\"                           // Kontrolle\n}\n    \n\n, respectcase: global dtalist: dir \"${pfad}\" files \"baua*.dta , respectcase\" würde “BAUA.dta” ignorieren.\n\n5.1.1 copy\nMit copy können wir Dateien kopieren.\n\nloc usefile `: word 1 of ${dtalist}'                // erster Eintrag aus der Liste\nloc copyfile \"copy_`usefile'\"\ndis \"`usefile'\"\ndis \"`copyfile'\"\n\ncopy ${pfad}/`usefile' ${pfad}/`copyfile' , replace\n\n// hat das geklappt?\nglobal dtalist2: dir \"${pfad}\" files \"*baua*.dta\" // Liste aller .dta-Dateien\nmac l dtalist\nmac l dtalist2\n\n\n\n5.1.2 erase\nMit erase können wir Dateien löschen.\n\nloc usefile `: word 1 of ${dtalist}'                // erster Eintrag aus der Liste\nloc copyfile \"copy_`usefile'\"\nerase ${pfad}/`copyfile'\n\n// hat auch das geklappt?\nglobal dtalist3: dir \"${pfad}\" files \"*baua*.dta\" // Liste aller .dta-Dateien\nmac l dtalist\nmac l dtalist2\nmac l dtalist3\n\n\nÜbung"
  },
  {
    "objectID": "05_Daten.html#verzeichnisse-dofiles-erstellen",
    "href": "05_Daten.html#verzeichnisse-dofiles-erstellen",
    "title": "5  Dateien- und DoFile-Verwaltung",
    "section": "5.2 Verzeichnisse & DoFiles erstellen",
    "text": "5.2 Verzeichnisse & DoFiles erstellen\nMit mkdir können wir Verzeichnisse erstellen:\n\nglobal pfad \"D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataProgBIBB\\projekt\"\nmkdir   \"${pfad}/data\"\nmkdir   \"${pfad}/log\"\nmkdir   \"${pfad}/graph\"\nmkdir   \"${pfad}/results\"\nmkdir   \"${pfad}/tables\"\n\nfile können wir nutzen, um ein DoFile mit globals zu erstellen (oder natürlich auch locals oder allen anderen Informationen):\n\n*erstelle doFile fuer macros -> kurzes doFile um Pfade in Schleifen richtig zu setzen, wird dann in Schleifen immer aufgerufen\nfile open macros using ${prog}\\macrodofile.do, write replace\nfile write macros \"glo pfad     ${pfad}   \"     _n\nfile write macros \"glo orig     ${orig}   \"     _n\nfile write macros \"glo data     ${data}   \"     _n\nfile write macros \"glo log      ${log}    \"     _n\nfile write macros \"glo res      ${results}\"     _n\nfile write macros \"glo graph    ${graph}  \"     _n\nfile write macros \"glo prog     ${prog}   \"     _n\nfile close macros"
  },
  {
    "objectID": "05_Daten.html#master-dofile",
    "href": "05_Daten.html#master-dofile",
    "title": "5  Dateien- und DoFile-Verwaltung",
    "section": "5.3 Master DoFile",
    "text": "5.3 Master DoFile\n\n5.3.1 DoFile mit Argumenten starten\nEin DoFile kann auch direkt aus einem Master-DoFile gestartet werden. Werte, die wir danach angeben, können im DoFile mit der Angabe der Position abgerufen werden:\n\ndo \"${prog}/051_DoFile.do\" 2\n\n\nuse \"${orig}/BIBBBAuA_2018_suf1.0.dta\", clear\ndis \"Auszählung für `1'\"\ntab S1 if m1202 == `1'\n\n\ndo \"${prog}/051_DoFile2.do\" 4 2 mobil\n\n\nlocal ausb `1'\nlocal gend `2'\nlocal var  `3'\n\nuse \"${orig}/BIBBBAuA_2018_suf1.0.dta\", clear\ndis \"Auszählung für Ausbildung = `ausb' & Geschlecht = `gend'\"\ntab gkpol if m1202 == `ausb' & S1 == `gend'\n\ntab gkpol `var' if m1202 == `ausb' & S1 == `gend'\n\n\n\n5.3.2 in neuer Session starten\n\ncd ${prog}\nwinexec `c(sysdir_stata)'StataSE-64.exe do \"${prog}/052_DoFile1.do\" 4 2 mobil\n\nStartet 052_DoFile1.do in einer neuen Session.\nAchtung: hier sind dann auch die globals, locals usw. weg. Um die globals zu übernehmen, muss dann ein macrodofile eingebunden werden.\n\n\n5.3.3 mehrere Sessions starten\n\nforvalues s = 1/2{\n    cd ${prog}\n    winexec `c(sysdir_stata)'StataSE-64.exe do \"${prog}/052_DoFile1.do\" 4 `s' mobil\n}\n\n\nÜbung"
  },
  {
    "objectID": "05_Daten.html#übungen",
    "href": "05_Daten.html#übungen",
    "title": "5  Dateien- und DoFile-Verwaltung",
    "section": "5.4 Übungen",
    "text": "5.4 Übungen\n\n5.4.1 Übung\n\nIm zip-Ordner dir_übung.zip finden sich auch .csv-Dateien. Lesen Sie diese nach der Reihe ein und speichern Sie die Daten als .dta - danach können alle Datensätze zusammengefügt werden.\n\nEntpacken Sie die Dateien aus dem zip-Ordner in passendes ein Verzeichnis (bspw., das welches Sie mit $data ansteuern).\nVerwenden Sie also die filelist statt der dtalist von oben.\nLesen Sie mit import delimited \".... baua3.csv\", delimiter(\";\") encoding(ISO-8859-2) clear die csv-Dateien jeweils ein und legen Sie als dta ab.\nAnschließend können Sie den dta-Schleife von oben verwenden, um alle Teildatensätze einzulesen. Wie viele Fälle haben Sie im Datensatz?\n\nKopieren Sie eine der Dateien und löschen Sie sie anschließend wieder.\n\n\n\n5.4.2 Übung\n\nStarten Sie getrennte Auswertungen für Männer und Frauen für das Merkmal zpalter, bspw. mit summary und stoßen Sie dieses mit do ... an."
  },
  {
    "objectID": "05_Daten.html#anhang",
    "href": "05_Daten.html#anhang",
    "title": "5  Dateien- und DoFile-Verwaltung",
    "section": "5.5 Anhang",
    "text": "5.5 Anhang\nweitere File-Loops"
  },
  {
    "objectID": "05_weiteres.html#capture",
    "href": "05_weiteres.html#capture",
    "title": "6  Weitere macro & matrix Funktionen",
    "section": "6.1 capture",
    "text": "6.1 capture\n\ncap drop S01 zpalter\nd S0? zp*"
  },
  {
    "objectID": "05_weiteres.html#macro-extended-functions-for-parsing",
    "href": "05_weiteres.html#macro-extended-functions-for-parsing",
    "title": "6  Weitere macro & matrix Funktionen",
    "section": "6.2 Macro extended functions for parsing",
    "text": "6.2 Macro extended functions for parsing\n\nlocal wanted : di _dup(10) \"oo \"\nlocal wanted : di _dup(10) \"oo \"\ndis \"`wanted'\"\n\nlocal wanted : di \"{dup 10:99 }\"\n\noo oo oo oo oo oo oo oo oo oo"
  },
  {
    "objectID": "05_weiteres.html#weitere-matrix-befehle",
    "href": "05_weiteres.html#weitere-matrix-befehle",
    "title": "6  Weitere macro & matrix Funktionen",
    "section": "6.3 weitere matrix-Befehle",
    "text": "6.3 weitere matrix-Befehle\nWir können auch Rechnungen einfügen:\n\nmatrix X1 = (1+1, 2*3/4 \\ 5/2, 3)\nmat l X1 \n\nX1[2,2]\n     c1   c2\nr1    2  1.5\nr2  2.5    3\n\n\n\n6.3.1 Teilmatrizen\n\nmat X1 = (1,2,3,4,5 \\ 6,7,8,9,10 \\ 0,-1,-2,-3,-5 \\ -6,-7,-8,-9,-10)\nmat l X1\n\nX1[4,5]\n     c1   c2   c3   c4   c5\nr1    1    2    3    4    5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\nWir können aus diesen Matrizen auch Teilbereiche auswählen:\n\nmatrix newmat = oldmat[Zeile(nbereich), Spalte(nbereich)]\n\nZeilenbereich und Spaltenbereich können einzelne Zahlen oder Bereiche mit durch zwei Punkte getrennten Start- und Endpositionen sein.\nMatrix B erstellen, welche die Zeile 2-4 und die Spalte 1-5 von X1 enthält:\n\nmatrix B = X1[2..4,1..5]\nmat l B\nmat l X1\n\n\n\nB[3,5]\n     c1   c2   c3   c4   c5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\nX1[4,5]\n     c1   c2   c3   c4   c5\nr1    1    2    3    4    5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\nUm alle Zeilen nach der zweiten Zeile zu übernehmen, verwenden wir drei Punkte:\n\nmatrix C = X1[2...,1..5]\nmat l C\nmat l X1\n\n\n\nC[3,5]\n     c1   c2   c3   c4   c5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\nX1[4,5]\n     c1   c2   c3   c4   c5\nr1    1    2    3    4    5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\n\n\n6.3.2 Spalten/Zeilen auswählen\nB1 enthält Spalte 1 und 3 aus X1:\n\nmat B1 = X1[1...,1],X1[1...,3]\nmat l B1\nmat l X1\n\n\n\nB1[4,2]\n    c1  c3\nr1   1   3\nr2   6   8\nr3   0  -2\nr4  -6  -8\n\n\nX1[4,5]\n     c1   c2   c3   c4   c5\nr1    1    2    3    4    5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\nB2 enthält Zeile 1 und 3 aus X1:\n\nmat B2 = X1[1,1...] \\ X1[4,1...]\nmat l B2\nmat l X1\n\n\n\nB2[2,5]\n     c1   c2   c3   c4   c5\nr1    1    2    3    4    5\nr4   -6   -7   -8   -9  -10\n\n\nX1[4,5]\n     c1   c2   c3   c4   c5\nr1    1    2    3    4    5\nr2    6    7    8    9   10\nr3    0   -1   -2   -3   -5\nr4   -6   -7   -8   -9  -10\n\n\n\n\n\n6.3.3 Namensbasierte Auswahl\nHier helfen rownumb und colnumb\n\nmat X1 = (1,2,3 \\ 8,9,10 )\nmat colname X1 = var1 var2 var3\nmat rowname X1 = set1 set2\n\nmat X2 = X1[rownumb(X1,\"set1\"),1...]\nmat l X2\n\nX2[1,3]\n      var1  var2  var3\nset1     1     2     3\n\n\n\nmat X3 = X1[1...,colnumb(X1,\"var2\")]\nmat l X3\n\n\n\nX3[2,1]\n      var2\nset1     2\nset2     9"
  },
  {
    "objectID": "06_lit.html",
    "href": "06_lit.html",
    "title": "7  Literatur & Links",
    "section": "",
    "text": "Stata Cookbook\nStata Coding Guide\nAusführliche Einführung in frames\nStata Cheatsheets"
  }
]