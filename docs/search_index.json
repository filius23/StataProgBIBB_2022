[["index.html", "Stata für Fortgeschrittene: Programmieren mit Postestimates, Macros und Schleifen in Stata Herzlich Willkommen", " Stata für Fortgeschrittene: Programmieren mit Postestimates, Macros und Schleifen in Stata Andreas Filser 2022-09-08 Herzlich Willkommen Hier entsteht das Begleitskript für die Weiterbildung Programmieren mit Postestimates, Macros und Schleifen in Stata am BIBB von Andreas Filser am 24.10.2022 "],["macro.html", "1 Macros 1.1 = macht einen Unterschied 1.2 local und global sind getrennte Welten 1.3 Macros mit Text 1.4 Dateipfade 1.5 Bereits definierte Macros 1.6 Wenn nicht if, dann else 1.7 Unterbrechen wenn ein Fehler vorliegt 1.8 Schleifen: foreach &amp; forvalues 1.9 Übungen 1.10 Anhang", " 1 Macros Macros ist die Sammelbezeichung für globals und locals in Stata. Beide dienen zur (vorläufigen) Speicherung von Text- oder Zahleninformationen. Definiert werden sie durch globalinhalt oder localinhalt - oft mit glo und loc als Abkürzungen. globals können dann mit $globalname/${globalname} aufgerufen werden, locals mit `localname' - ganz einfach bspw. mit dis[play]: glo x = 1 loc y = 2 dis ${x} dis `y&#39; 1 2 …oder mit macro list, hier sind die macros aber ohne “punctuation” (also $ oder `') glo x = 1 loc y = 2 mac list x mac list _y x: 1 _y: 2 Der Unterschied besteht vor allem darin, dass local macros ‘lokal’ für ein spezifisches Programm verfügbar sind, globale macros hingegen für alle Programme (innerhalb einer Stata-Session) verfügbar sind. Letztlich können wir jede Instanz, in der wir mehrere Zeilen eines DoFiles ausführen als ‘Programm’ ansehen. globals können wir später nochmal aufrufen, locals nicht: mac list xg xg: 1 mac list _xl r(111); end of do-file r(111); 1.1 = macht einen Unterschied In der Regel können wir auch einfach glo glname Wert bzw. loc locname Wert statt glo glname = Wert bzw. loc locname = Wert angeben. Allerdings ist hier etwas Vorsicht geboten, denn das = ist entscheidend ob die Rechnung abgelegt wird oder das Ergebnis (Stichwort evaluation): + Mit = : der Ausdruck wird “evaluated” + Ohne = : der Ausdruck wird “aliased” Im Ergebnis sehen wir hier beides Mal das gleiche: local m1 2+2 display `m1&#39; 4 local m2 = 2+2 display `m2&#39; 4 Aber wenn wir uns mit mac list die abgelegten Infos ansehen, dann sehen wir den entscheidenden Unterschied: mac list _m1 _m2 _m1: 2+2 _m2: 4 Wenn wir nämlich mit m1 und m2 weiterrechnen, da kann folgendes passieren: local m1 2+2 display `m1&#39;*4 10 local m2 = 2+2 display `m2&#39;*4 16 Denn \\(2+2*4\\neq4*4\\) 1.2 local und global sind getrennte Welten Geht, aber ist nicht zu empfehlen: glo yx = 1 loc yx = 2 mac list yx mac list _yx yx: 1 _yx: 2 1.3 Macros mit Text Wir können macros zu Texten zusammenbauen: glo t1 &quot;Hallo&quot; glo t2 &quot; zusammen&quot; glo t3 &quot;! :-)&quot; glo t4 = &quot;${t1}${t2}${t3}&quot; dis &quot;${t4}&quot; mac list t1 t2 t3 t4 Hallo zusammen! :-) t1: Hallo t2: zusammen t3: ! :-) t4: Hallo zusammen! :-) Übung 1.4 Dateipfade Ein macro kann auch Text enthalten und wir können diesen bspw. für Dateipfade macros verwenden: glo pfad &quot;D:\\Projekt\\daten\\BIBB_BAuA&quot; // wo liegt der Datensatz? use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Wir können das auch nutzen, um DoFiles in Kooperationsprojekten zu bauen, wenn verschiedenen Personen die DoFiles verwenden: glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; Micha würde dann immer den Pfad von Alex überspringen/auskommentieren und umgekehrt. Wir lernen gleich noch eine Möglichkeit kennen, das auch direkt mit zu lösen mit dem Usernamen der verwendeten PCs. use &quot;${data}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Die \" \" sind nicht zwingend nötig in diesem Fall. Sollten aber Leerzeichen im Pfad vorkommen, brauchen wir auf jeden Fall \" \". Außerdem ist \\ beim Zusammenbauen mit macros manchmal problematisch) - auch hier helfen \" \". Alternativ hilft hier / statt \\ zu verwenden. Mit mkdir können wir auch Ordner erstellen. Wenn also noch kein log-Ordner existiert, können wir ihn so erstellen: mkdir ${log} Mit cap cd können wir das vorher überprüfen: capture cd &quot;${log}&quot; if _rc!=0 { mkdir ${log} display &quot;${log} erstellt&quot; } Siehe 01_init_beispiel.do für ein Beispiel für einige Befehle beim Erstellen eines Projektverzeichnisses. 1.5 Bereits definierte Macros Mit mac list bekommen wir auch einige von Stata bereits vorgegebenen Macros angezeigt. mac list Zwei sehr nützliche sind dabei $S_DATE $S_TIME - das aktuelle Datum und die aktuelle Zeit: dis &quot;$S_DATE&quot; dis &quot;$S_TIME&quot; 2 May 2022 12:44:22 Diese können wir beispielsweise am Anfang und Ende eines Abschnitts in einem LogFiles einblenden, um Start- und Endzeit zu dokumentieren: log using &quot;${log}/logfile.txt&quot;, t replace use .... dis &quot;Start: $S_DATE um $S_TIME&quot; . . Hier kommen aufwändige Modelle . . . dis &quot;Ende: $S_DATE um $S_TIME&quot; . . . cap log close So können wir beispielsweise automatisch log-Files mit einem Datum versehen: global date = string( d($S_DATE), &quot;%tdCY-N-D&quot; ) * help datetime_display_formats // für andere Datumsformate cap log close log using &quot;${log}/01_macro_loops_${date}.log&quot;, replace text . log using &quot;${log}/01_macro_loops_${date}.log&quot;, replace text (note: file D:\\Arbeit\\Alex/log/01_macro_loops_2021-12-01.log not found) -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- name: &lt;unnamed&gt; log: D:\\Arbeit\\Alex/log/01_macro_loops_2021-12-01.log log type: text opened on: 01 Dec 2021, 10:45:04 Außerdem gibt es einige locals mit nützlichen Infos: dis &quot;`c(username)&#39;&quot; dis &quot;`c(machine_type)&#39;&quot; dis &quot;`c(os)&#39;&quot; Filser PC (64-bit x86-64) Windows Weitere “system parameters and settings” unter help creturn bspw.: c(changed) returns a numeric scalar equal to 0 if the dataset in memory has not changed since it was last saved and 1 otherwise. c(filename) returns a string containing the filename last specified with a use or save, such as \"C:\\Data\\auto.dta\". c(filedate) returns a string containing the date and time the file in c(filename) was last saved, such as “7 Jul 2016 13:51”. 1.5.1 if Mit if (local== \"...\") können wir macros abgleichen, um Befehle nur unter bestimmten Bedingungen auszuführen: if (&quot;`c(username)&#39;&quot; == &quot;Filser&quot;) display &quot;Du bist Filser&quot; if (&quot;`c(username)&#39;&quot; != &quot;Fischer&quot;) display &quot;Du bist nicht Fischer&quot; Das können wir für den Fall von eben mit mehreren Nutzern nutzen: if (&quot;`c(username)&#39;&quot; == &quot;Alex&quot;) glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? if (&quot;`c(username)&#39;&quot; == &quot;Micha&quot;) glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? glo prog &quot;${pfad}/prog&quot; glo data &quot;${pfad}/data&quot; glo log &quot;${pfad}/log&quot; use &quot;${pfad}/BIBBBAuA_2018_suf1.0.dta&quot;, clear // laden des Datensatzes Für if-Bedingungen stehen uns die üblichen Operatoren zur Verfügung, die wir auch aus den if-Statements in Befehlen kennen: &gt;, &lt;, ==, &gt;=, &lt;=, !=/~= (ungleich) Mit | können wir oder-Bedingungen stellen. inrange: einen Wertebereich auswählen loc x = 20 if `x&#39; &gt;= 20 &amp; `x&#39; &lt;= 30 display &quot;&amp; yes&quot; if inrange(`x&#39;,20,30) display &quot;inrange yes&quot; loc x = 19 if inrange(`x&#39;,20,30) display &quot;yes&quot; inlist: spezifische Werte angeben, um lange Folgen von | zu vermeiden: loc x = 20 if `x&#39; == 18 | `x&#39; == 20 | `x&#39; == 22 | `x&#39; == 28 display &quot;| yes&quot; if inlist(`x&#39;,18,20,22,28) display &quot;inlist yes&quot; 1.5.2 Macros als Variablennamen und Befehle Auch so etwas ist möglich: local n 200 su F`n&#39; Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- F200 | 17,953 36.24272 14.03048 1 99 Ein macro kann auch ein Programm sein: loc t tab `t&#39; mobil Mobilfunkin | terview | Freq. Percent Cum. ------------+----------------------------------- Festnetz | 14,008 70.00 70.00 Mobilfunk | 6,004 30.00 100.00 ------------+----------------------------------- Total | 20,012 100.00 \\(\\Rightarrow\\) sollen macros als Text verstanden werden, sind \"\" nötig: loc opt ja if inlist(`opt&#39;,&quot;ja&quot;,&quot;JA&quot;,&quot;Ja&quot;,&quot;ok&quot;) tab mobil ja not found r(111); end of do-file r(111); loc opt ja if inlist(&quot;`opt&#39;&quot;,&quot;ja&quot;,&quot;JA&quot;,&quot;Ja&quot;,&quot;ok&quot;) tab mobil Mobilfunkin | terview | Freq. Percent Cum. ------------+----------------------------------- Festnetz | 14,008 70.00 70.00 Mobilfunk | 6,004 30.00 100.00 ------------+----------------------------------- Total | 20,012 100.00 1.5.3 globals durchsuchen Mit Hilfe sog. Wildcards können wir Zeichen “offen lassen”: ? ersetzt ein Zeichen * mehrere oder keines glo x1 = 2 glo x2 &quot;das ist x2&quot; glo x 291 global allglo: all globals &quot;x*&quot; global allglo2: all globals &quot;x?&quot; mac l allglo2 allglo allglo2: x2 x1 allglo: x x2 x1 Hier haben wir auch schon die dritte Form der macro Definition kennengelernt, die sog. extended macro function, welche auf : folgt. Hier also all globals, im Laufe dieses Kurses werden wir noch zahlreiche dieser Funktionen kennenlernen. 1.6 Wenn nicht if, dann else Mit if haben wir die Möglichkeiten aber noch nicht ausgeschöpft - aus help if: if `n&#39;==1 { local word &quot;one&quot; } else if `n&#39;==2 { local word &quot;two&quot; } else if `n&#39;==3 { local word &quot;three&quot; } else { local word &quot;big&quot; } display &quot;`word&#39;&quot; 1.7 Unterbrechen wenn ein Fehler vorliegt Mit exit (help exit_program) können wir Stata zu einer Unterbrechung bringen: exit causes Stata to terminate the current process and returns control to the calling process. if &quot;`c(username)&#39;&quot; == &quot;Alex&quot; { glo pfad &quot;C:\\Projekte\\Micha&quot; // wo liegt der Datensatz bei Alex? } else if &quot;`c(username)&#39;&quot; == &quot;Micha&quot; { glo pfad &quot;D:\\Arbeit\\Alex&quot; // wo liegt der Datensatz bei Micha? } else { display as error &quot;Hier fehlt der passende Pfad&quot; exit } tab mobil Hier fehlt der passende Pfad end of do-file Übung 1.8 Schleifen: foreach &amp; forvalues Schleifen helfen uns das DRY (“Don’t repeat yourself”) Prinzip umzusetzen. tab S1 if zpalter &lt;= 19 tab S1 if zpalter &lt;= 24 tab S1 if zpalter &lt;= 29 foreach v of numlist 19(5)29 { display &quot;Alter bis `v&#39;&quot; tab S1 if zpalter &lt;= `v&#39; } Ein vereinfachtes Syntaxdiagramm der foreach-Schleife sieht so aus: foreach lname listtype list { Befehle } lname steht dabei für ein local macro. Wir können unterschiedliche Typen von foreach-Listen verwenden: – of varlist: Variablenlisten – of newlist: neue Variablen – of numlist: Nummernlisten - bspw. (0(1)5) \\(\\Rightarrow\\) “1 bis 5 in Schritten von 1” weitere Varianten – in: beliebige Listen von Buchstaben, Zahlen oder Wörtern (durch Leerzeichen getrennt) foreach lname in any_list { foreach lname of local local { foreach lname of global global { foreach lname of varlist variablen { //auch Wildcards möglich - analog zu d F2** foreach lname of newlist newvarlist { //wenn variablen erst generiert werden foreach lname of numlist numlist { foreach n of numlist 1/3 6(1)9 { dis &quot;`n&#39;&quot; } 1 2 3 6 7 8 9 foreach n of numlist 6 4: -4 { dis &quot;`n&#39;&quot; } 6 4 2 0 -2 -4 1.8.1 ferest() Mit ferest() können wir uns die “noch übrigen Werte in der Liste anzeigen lassen: foreach n of numlist 1(1)5 { dis &quot;`n&#39;&quot; dis &quot;Es kommen noch: `ferest()&#39;&quot; } 1 Es kommen noch: 2 3 4 5 2 Es kommen noch: 3 4 5 3 Es kommen noch: 4 5 4 Es kommen noch: 5 5 Es kommen noch: 1.8.2 Weitere Schleifentypen Es gibt außerdem forvalues: forvalues lname=range { Befehle } forvalues-Schleife ist eine foreach-Schleife mit numlist. Aber: Die foreach-Schleife mit einer numlist funktioniert nicht mit einer beliebig hohen Anzahl von Ziffern. In der forvalues-Schleife gibt es keine Beschränkung. Außerdem ist forvalues-Schleife schneller im Abarbeiten von Nummernlisten. Und dann gibt es noch die while-Schleife: loc i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; loc i = `i&#39; + 1 } 1 2 3 4 5 Eine Besonderheit bei locals ist, dass wir mit loc ++i den Wert um 1 erhöhen können. Somit führt folgende Syntax zum gleichen Ergebnis: loc i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; loc ++i } 1.8.3 Anwendung foreach v of numlist 19(5)35 { display &quot;Alter bis `v&#39;&quot; tab S1 if zpalter &lt;= `v&#39; } Alter bis 19 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 41 67.21 67.21 weiblich | 20 32.79 100.00 ------------+----------------------------------- Total | 61 100.00 Alter bis 24 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 373 65.10 65.10 weiblich | 200 34.90 100.00 ------------+----------------------------------- Total | 573 100.00 Alter bis 29 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 991 60.46 60.46 weiblich | 648 39.54 100.00 ------------+----------------------------------- Total | 1,639 100.00 Alter bis 34 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 1,984 59.03 59.03 weiblich | 1,377 40.97 100.00 ------------+----------------------------------- Total | 3,361 100.00 …oder mit inrange(), um lediglich die 5-Jahresaltersgruppe anzuzeigen: foreach v of numlist 19(5)35 { display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; tab S1 if inrange(zpalter,`v&#39;-4, `v&#39;) *su zpalter if inrange(zpalter,`v&#39;-4, `v&#39;) } Alter 15 bis 19 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 41 67.21 67.21 weiblich | 20 32.79 100.00 ------------+----------------------------------- Total | 61 100.00 Alter 20 bis 24 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 332 64.84 64.84 weiblich | 180 35.16 100.00 ------------+----------------------------------- Total | 512 100.00 Alter 25 bis 29 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 618 57.97 57.97 weiblich | 448 42.03 100.00 ------------+----------------------------------- Total | 1,066 100.00 Alter 30 bis 34 Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 993 57.67 57.67 weiblich | 729 42.33 100.00 ------------+----------------------------------- Total | 1,722 100.00 1.8.4 Schleifen aufbauen Einfache Schleife mit if/else: ist Zahl gerade oder ungerade? loc n = 5 if trunc(`n&#39;/2) == `n&#39;/2 display &quot;ja&quot; if trunc(`n&#39;/2) != `n&#39;/2 display &quot;nein&quot; loc n = 5 dis mod(`n&#39;,2) forvalues n = 1/10 { if mod(`n&#39;,2) == 0 dis &quot;`n&#39; ist gerade&quot; if mod(`n&#39;,2) &gt; 0 dis &quot;`n&#39; ist ungerade&quot; } forvalues n = 1/10 { if mod(`n&#39;,2) == 0 { dis &quot;`n&#39; ist gerade&quot; } else if mod(`n&#39;,2) &gt; 0 { dis &quot;`n&#39; ist ungerade&quot; } } mod() ist der Modulo-Operator in Stata - es wird der “Rest” berechnet 1.8.5 nested loop forvalues n1 = 1/3 { forvalues n2 = 1/3 { dis &quot;n1 ist `n1&#39; und n2 ist `n2&#39; &quot; } } n1 ist 1 und n2 ist 1 n1 ist 1 und n2 ist 2 n1 ist 1 und n2 ist 3 n1 ist 2 und n2 ist 1 n1 ist 2 und n2 ist 2 n1 ist 2 und n2 ist 3 n1 ist 3 und n2 ist 1 n1 ist 3 und n2 ist 2 n1 ist 3 und n2 ist 3 1.8.6 display vs. macro list macro list stoppt das DoFile wenn der macro nicht existiert, display zeigt nur ein leeres Feld an: global labormarket LABOUR display &quot;${labormarket}&quot; display &quot;${labourmarket}&quot; LABOUR mac list labormarket mac list labourmarket labormarket: LABOUR global macro $labourmarket not found r(111); Übung 1.9 Übungen 1.9.1 Übung Was ist das Ergebnis dieser Rechnung? Nehmen Sie sich einen Moment Zeit und rechnen Sie im Kopf - Überprüfen Sie dann ihr Ergebnis. loc x = 4 glo y = 1+5 loc y 1+5 dis `x&#39; * `y&#39; Wie können Sie hier aus Hallo zusammen! :-) folgende Ausgabe machen: Hallo, zusammen! :-) ohne die macros zu verändern oder einen neuen anzulegen? glo t1 &quot;Hallo&quot; glo t2 &quot; zusammen&quot; glo t3 &quot;! :-)&quot; glo t4 = &quot;${t1}${t2}${t3}&quot; dis &quot;${t4}&quot; 1.9.2 Übung Pfad zusammenbauen für use: Erstellen Sie den Pfad für den use-Befehl schrittweise und unter Berücksichtigung Ihres Usernamens. ggf. Dateiverzeichnis einrichten mit Ordner log, prog und data (gerne auch mehr oder andere Namen) Legen Sie die Erwerbstätigenbefragung 2018 in den data-Ordner (oder dessen Äquivalent) Wie ist der Username auf Ihrem Gerät? Verwenden Sie ein if-Statement, um den Dateipfad zu erstellen Erstellen Sie ein LogFile, welches das heutige Datum im Namen trägt. Lassen Sie sich alle globals, die mit “S” beginnen, in ein gobal allS ablegen. Was wurde alles gefunden? Denken Sie an die extended macro function all globals Wie könnten Sie eine Schleife bauen, die nacheinander alle globals anzeigt, die mit “S” beginnen? 1.9.3 FizzBuzz-Challenge Fizz Buzz wird/wurde als ein Screening-Instrument für Programmierer*innen verwendet. Fizz Buzz ist ein Kinderlernspiel, bei dem die Kinder üblicherweise im Kreis sitzen und reihum laut von eins aufwärts zählen. Allerdings gibt es drei Regeln: Alle Zahlen, die durch drei teilbar sind, müssen durch das Wort “Fizz” ersetzt werden Alle Zahlen, die durch fünf teilbar sind, müssen durch das Wort “Buzz” ersetzt werden Wenn eine Zahl durch drei und fünf teilbar ist, dann wird “Fizz Buzz” gerufen. Wie würden Sie mit if &amp; else eine Schleife bauen, welche diese Regeln umsetzt. Was wäre der erste Schritt? Bauen Sie dann die Schleife und lassen Sie die Schleife für den Wertebereich 0-30 laufen. 1.9.4 Übung Passen Sie die Schleife mit ferest() an, sodass hier im 5. Durchlauf nicht mehr Es kommen noch: steht, sondern Fertig. 1.10 Anhang 1.10.1 Windows Dateipfade mit macros Aus der Stata-Doku zu macros: Stata uses the  character to tell its parser not to expand macros. Windows uses the  character as the directory path separator. Mostly, there is no problem using a  in a filename. However, if you are writing a program that contains a Windows path in macro path and a filename in fname, do not assemble the final result as ‘path’\\‘fname’ because Stata will interpret the  as an instruction to not expand ‘fname’. \\(\\Rightarrow\\) Instead, assemble the final result as ‘path’/‘fname’. Stata understands / as a directory separator on all platforms. 1.10.2 Debugging: Wo ist der Wurm drin? Fehlersuch in langen foreach-Schleifen kann mühsam und nervig sein. in many cases you would like to go throuh the code step by step then, however, the value of the loop index (which is a local) In vielen Fällen möchte man den Code Schritt für Schritt durchgehen, dann aber den Wert des Schleifen-locals ist natürlich nach Abbruch der Schleife nicht mehr da. forvalues y = 1982/1985 { use &quot;${data}/wages-year`y&#39;&quot;, clear capture log close log using &quot;${data}/log`y&#39;.log&quot;, text replace regress lwage exper expersq educ avplots graph export &quot;${graph}/avplots`y&#39;.png&quot;, replace } Manchmal hilft ein einfacher Workaround: ein global aus dem local definieren: forvalues y = 1982/1985 { global Y = `y&#39; use &quot;${data}/wages-year`y&#39;&quot;, clear capture log close log using &quot;${data}/log`y&#39;.log&quot;, text replace regress lwage exper expersq educ avplots graph export &quot;${graph}/avplots`y&#39;.png&quot;, replace } Alternativ hilft häufig auch set trace on weiter. Hier werden immer die zuerst die macros und dann die eingesetzten Werte angezeigt: set trace on foreach v of numlist 19(5)35 { display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; } - foreach v of numlist 19(5)35 { - display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; = display &quot;Alter &quot; 19 - 4 &quot; bis &quot; 19 Alter 15 bis 19 - } - display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; = display &quot;Alter &quot; 24 - 4 &quot; bis &quot; 24 Alter 20 bis 24 - } - display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; = display &quot;Alter &quot; 29 - 4 &quot; bis &quot; 29 Alter 25 bis 29 - } - display &quot;Alter &quot; `v&#39; - 4 &quot; bis &quot; `v&#39; = display &quot;Alter &quot; 34 - 4 &quot; bis &quot; 34 Alter 30 bis 34 - } "],["loopmacro.html", "2 Schleifen aus Macros 2.1 local erstellen und für Schleifen verwenden 2.2 Schleifen über strings 2.3 Informationen aus Schleifen behalten 2.4 Ergebnisse weiter verwenden 2.5 Kennzahlen in einer matrix ablegen 2.6 Labels behalten 2.7 Von der matrix zum Datensatz 2.8 frame: mehrere Datensätze in Stata 2.9 Übungen", " 2 Schleifen aus Macros 2.1 local erstellen und für Schleifen verwenden Schleifen aus globals / locals mit Hilfe von levelsof: tab m1202 levelsof m1202 levelsof m1202, loc(ausb) foreach lvl of local ausb { dis &quot;m1202: &quot; `lvl&#39; } levelsof m1202, loc(ausb) glo ausb `ausb&#39; mac l ausb foreach lvl of global ausb { dis &quot;m1202: &quot; `lvl&#39; } foreach lvl of global ausb { dis &quot;m1202: &quot; `lvl&#39; tab S1 if m1202 == `lvl&#39; } 2.2 Schleifen über strings 2.2.1 Wörter indizieren local phrase `&quot; &quot;2 guys&quot; &quot;1 girl&quot; &quot;1 pizza place&quot; &quot;&#39; di &quot;`:word 2 of `phrase&#39; &#39;&quot; 1 girl 2.2.2 Wörter zählen local sentence &quot;here is a sentence 7&quot; local len: word count `sentence&#39; mac list _len _len: 5 2.2.3 Wörter in Schleife local phrase1 &quot;here is a sentence of 7 words&quot; local len1: word count `phrase1&#39; forvalues i = 1(1)`len1&#39; { loc word: word `i&#39; of `phrase1&#39; dis &quot;this is word number &quot; `i&#39; &quot;: `word&#39;&quot; } this is word number 1: here this is word number 2: is this is word number 3: a this is word number 4: sentence this is word number 5: of this is word number 6: 7 this is word number 7: words … dabei macht es einen Unterschied, wo die \"\" stehen: local phrase2 `&quot; &quot;here is&quot; &quot;a sentence&quot; &quot;of 7 words&quot; &quot;&#39; local len2: word count `phrase2&#39; forvalues i = 1(1)`len2&#39; { loc word: word `i&#39; of `phrase2&#39; dis &quot;this is word number &quot; `i&#39; &quot;: `word&#39;&quot; } this is word number 1: here is this is word number 2: a sentence this is word number 3: of 7 words Übung 2.3 Informationen aus Schleifen behalten 2.3.1 Gespeichterte Ergebnisse Um auf Ergebnisse zuzugreifen, können wir etwas hinter die Kulissen der Stata-Befehle sehen: Befehl zeigt alle c-class system parameters &amp; settings finden wir als c() - siehe `c(username)' r-class die meisten deskriptiven Befehle speichern die Ergebnisse in in r() e-class …außer estimation commands, wie bspw. reg - hier wird in e() gespeichert (Postestimates) s-class parsing commands store results in s() used by programmers n-class commands that do not store in r(), e(), oder s() Jeweils alle Werte anzeigen mit: Befehl zeigt alle return list r() ereturn list e() sreturn list s() creturn list c() Es gibt dabei vier Typen an Ergebnissen: macro: strings mit mehreren Wörtern (Text) matrix: bspw. e(b) sind die Koeffizienten nach einem reg-Befehl oder e(V) ist die Varianz–Kovarianz Matrix der estimates (VCE) scalar: einzelne Zahlen/Strings (1x1 Matrizen) functions: bspw. e(sample) \\(\\Rightarrow\\) 1 (true) wenn die Beobachtung im vorheringen “estimation command” verwendet wurde und 0 (false) wenn nicht tab S1 return list Geschlecht | Freq. Percent Cum. ------------+----------------------------------- männlich | 10,074 50.34 50.34 weiblich | 9,938 49.66 100.00 ------------+----------------------------------- Total | 20,012 100.00 scalars: r(N) = 20012 r(r) = 2 su S1 return list Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- S1 | 20,012 1.496602 .5000009 1 2 scalars: r(N) = 20012 r(sum_w) = 20012 r(mean) = 1.496602038776734 r(Var) = .2500009464113147 r(sd) = .500000946410419 r(min) = 1 r(max) = 2 r(sum) = 29950 reg F518_SUF zpalter ereturn list Source | SS df MS Number of obs = 16,543 -------------+---------------------------------- F(1, 16541) = 105.36 Model | 1.3092e+09 1 1.3092e+09 Prob &gt; F = 0.0000 Residual | 2.0555e+11 16,541 12426773 R-squared = 0.0063 -------------+---------------------------------- Adj R-squared = 0.0063 Total | 2.0686e+11 16,542 12505168 Root MSE = 3525.2 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- zpalter | 24.62253 2.398848 10.26 0.000 19.92053 29.32453 _cons | 2381.28 115.577 20.60 0.000 2154.736 2607.823 ------------------------------------------------------------------------------ scalars: e(N) = 16543 e(df_m) = 1 e(df_r) = 16541 e(F) = 105.3561454498825 e(r2) = .0063290815436915 e(rmse) = 3525.162828161657 e(mss) = 1309236899.97876 e(rss) = 205551251614.9366 e(r2_a) = .0062690083366028 e(ll) = -158590.4618746699 e(ll_0) = -158642.9792418738 e(rank) = 2 macros: e(cmdline) : &quot;regress F518_SUF zpalter&quot; e(title) : &quot;Linear regression&quot; e(marginsok) : &quot;XB default&quot; e(vce) : &quot;ols&quot; e(depvar) : &quot;F518_SUF&quot; e(cmd) : &quot;regress&quot; e(properties) : &quot;b V&quot; e(predict) : &quot;regres_p&quot; e(model) : &quot;ols&quot; e(estat_cmd) : &quot;regress_estat&quot; matrices: e(b) : 1 x 2 e(V) : 2 x 2 functions: e(sample) Anstatt zu versuchen, den Überblick darüber zu behalten, was wo gespeichert wird, finden wir ganz unten in jeder Hilfedatei einen Hinweis wie “summarize stores the following in r():” or “mean stores the following in e()” - entsprechend sehen wir die Ergebnisse in return bzw. ereturn. 2.3.2 e() und r() sind getrennte Welten Neben dem Prinzip “One Data” folgt Stata auch dem Prinzip “One _-class”. Das bedeutet, dass wir nur den return oder ereturn für den letzten Befehl dieser Klasse sehen können. Wenn wir also reg ausführen und dann eine Reihe von r-Klassen-Aufrufen machen (z.B. su), wird uns der Aufruf von ereturn immer noch die Werte für reg anzeigen. Sobald wir jedoch einen weiteren r-class-Befehl ausführen, verlieren wir den Zugriff auf die Ergebnisse des ersten Befehls. reg az F200 su az ereturn list Source | SS df MS Number of obs = 17,376 -------------+---------------------------------- F(1, 17374) = 33637.44 Model | 1269310.92 1 1269310.92 Prob &gt; F = 0.0000 Residual | 655608.985 17,374 37.735063 R-squared = 0.6594 -------------+---------------------------------- Adj R-squared = 0.6594 Total | 1924919.9 17,375 110.786757 Root MSE = 6.1429 ------------------------------------------------------------------------------ az | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- F200 | .9897533 .0053965 183.41 0.000 .9791755 1.000331 _cons | 3.937849 .1903973 20.68 0.000 3.564651 4.311047 ------------------------------------------------------------------------------ Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- az | 20,012 38.30557 11.75297 10 120 scalars: e(N) = 17376 e(df_m) = 1 e(df_r) = 17374 e(F) = 33637.43995203968 e(r2) = .6594097320849045 e(rmse) = 6.142887188019294 e(mss) = 1269310.915908093 e(rss) = 655608.9846442067 e(r2_a) = .6593901286390708 e(ll) = -56197.03934279057 e(ll_0) = -65554.6676770772 e(rank) = 2 macros: e(cmdline) : &quot;regress az F200&quot; e(title) : &quot;Linear regression&quot; e(marginsok) : &quot;XB default&quot; e(vce) : &quot;ols&quot; e(depvar) : &quot;az&quot; e(cmd) : &quot;regress&quot; e(properties) : &quot;b V&quot; e(predict) : &quot;regres_p&quot; e(model) : &quot;ols&quot; e(estat_cmd) : &quot;regress_estat&quot; matrices: e(b) : 1 x 2 e(V) : 2 x 2 functions: e(sample) 2.4 Ergebnisse weiter verwenden Alle diese Informationen können wir mit einem Makro speichern bzw. weiter verarbeiten. su S1 dis &quot;Der Mittelwert beträgt: &quot; r(mean) Der Mittelwert beträgt: 1.496602 su S1 dis &quot;Der Mittelwert beträgt: &quot; round(r(mean),.01) Der Mittelwert beträgt: 1.5 foreach lvl of global ausb { dis &quot;m1202: &quot; `lvl&#39; su S01 if m1202 == `lvl&#39; dis r(mean) } foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; dis &quot;Der Frauenanteil in m1202=&quot; `lvl&#39; &quot; beträgt: &quot; round(r(mean)*100,.1) &quot;%&quot; } foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; glo gend`lvl&#39;: display &quot;Der Frauenanteil in m1202=&quot; `lvl&#39; &quot; beträgt: &quot; round(r(mean)*100,.1) &quot;%&quot; } 2.4.1 Rekursivität Macros können auch “recursively” erstellt werden: global x &quot;&quot; forvalues i = 1/20 { global x $x `i&#39; } mac list x x: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 …somit können wir einen global auch zusammenbauen: glo gend &quot;&quot; foreach lvl of global ausb { qui su S01 if m1202 == `lvl&#39; glo gend: display &quot;${gend}m1202=&quot; `lvl&#39; &quot; &quot; round(r(mean)*100,.1) &quot;% &quot; } mac l gend 4. } gend: m1202=1 45.6% m1202=2 53% m1202=3 37.8% m1202=4 48.9% Übung 2.5 Kennzahlen in einer matrix ablegen Matrizen helfen uns, die ergebnisse in handhabarer Form zu speichern (help matrix). Um eine Tabelle zu bauen benötigen wir einige Matrix-Befehle, weiteres unter help matrix operators eine matrix ausgeben: matrix list matname eine matrix umbenennen: matrix umbenennen altername neuername eine matrix oder alle löschen: matrix drop [matlist] Operator Symbol column join , row join \\ transpose ’ negation - matrix Y1 = 1, 3 mat l Y1 Y1[1,2] c1 c2 r1 1 3 matrix Y2 = 4\\ 0 mat l Y2 Y2[2,1] c1 r1 4 r2 0 matrix Y = (2, 1.5 \\ 2.5, 3) mat l Y Y[2,2] c1 c2 r1 2 1.5 r2 2.5 3 Transponieren: matrix X2 = (1, 2, 3 \\ 5 , 8 , 9) mat l X2 mat X3 = X2&#39; mat l X3 X2[2,3] c1 c2 c3 r1 1 2 3 r2 5 8 9 X3[3,2] r1 r2 c1 1 5 c2 2 8 c3 3 9 Mit J(Zeilen,Spalten,Inhalt) können wir eine Matrix mit gleichen Werten besetzen: mat G0 = J(4,2,0) mat l G0 G0[4,2] c1 c2 r1 0 0 r2 0 0 r3 0 0 r4 0 0 2.5.1 Namen für Spalten und Zeilen einer matrix Aber wir können die Zeilennamen einer matrix verändern: mat colname G0 = var1 var2 mat list G0 G0[4,2] var1 var2 r1 0 0 r2 0 0 r3 0 2 r4 0 0 Wenn zu wenige Namen angegeben werden, wird der letzte Wert einfach wiederholt: mat rowname G0 = year result mat list X1 G0[4,2] c1 c2 year 0 0 result 0 0 result 0 2 result 0 0 2.5.2 matrix erstellen Das nutzen wir jetzt um unsere Ergebnisse zu speichern: levelsof m1202, loc(ausb) foreach lvl of local ausb { qui su S01 if m1202 == `lvl&#39; // 1. Spalte level von m1202 //2.Spalte: Frauenanteil mat G`lvl&#39; = `lvl&#39; ,r(mean)*100 } mat G = GX1\\GX2\\GX3\\GX4 mat colname G = m1202 share_w mat l G Damit können wir auch zeilenweise eine matrix befüllen, indem wir mit , mehrere Werte verbinden (row join): qui levelsof m1202, loc(ausb) foreach lvl of local ausb { qui su zpalter if m1202 == `lvl&#39;, det mat A`lvl&#39; = `lvl&#39;, r(p25), r(mean), r(p50), r(p75) } mat A = A1\\A2\\A3\\A4 mat colname A = m1202 p25 mean median p75 mat l A A[4,5] m1202 p25 mean median p75 r1 1 29 42.627213 46 55 r1 2 39 47.076531 49 56 r1 3 41 48.092344 50 56 r1 4 39 47.760744 49 57 Übung 2.6 Labels behalten 2.6.1 extended macro function für Labels Idealerweise würden wir aber gerne nicht nur 1-4 in m1202 behalten, sondern die Labels (Ohne Berufsabschluss) usw. Um Informationen zu Variablen &amp; Labels abzurufen, lernen wir später eine ganze Reihe an extended macro functions kennen, für den Moment reicht uns label (varname) varvalue: loc v m1202 local vallab1 : label (`v&#39;) 1 // Value label für Wert = 1 dis &quot;`vallab1&#39;&quot; // display local &quot;valuelab1&quot; Ohne Berufsabschluss In der Schleife können wir dann lvl entsprechen für label (var) lvl nutzen: loc lvl = 1 qui su zpalter if m1202 == `lvl&#39;, det mat GX = `lvl&#39;, r(p25), r(mean), r(p50), r(p75) local vallab1 : label (m1202) `lvl&#39; // label aufrufen 2.6.2 Labels als rowname Leider können wir nicht einfach die Labels der Variable in die matrix schreiben. In einer Matrix sind nur Zahlenwerte erlaubt: mat M = c(2\\&quot;label&quot;) r(133); end of do-file r(133); Aber wir können das Label als rowname ablegen: loc lvl = 1 qui su zpalter if m1202 == `lvl&#39;, det mat GX = `lvl&#39;, r(p25), r(mean), r(p50), r(p75) local vallab1 : label (m1202) `lvl&#39; // label aufrufen mat rowname GX = &quot;`vallab1&#39;&quot; // in Zeilenname ablegen mat l GX …damit erweitern wir die Schleife von oben: levelsof m1202, loc(ausb) foreach lvl of local ausb { qui su zpalter if m1202 == `lvl&#39;, det mat GX`lvl&#39; = `lvl&#39;, r(p25), r(mean), r(p50), r(p75) local vallab1 : label (m1202) `lvl&#39; mat rowname GX`lvl&#39; = &quot;`vallab1&#39;&quot; } mat G = GX1\\GX2\\GX3\\GX4 mat colname G = m1202 p25 mean median p75 mat l G 1 2 3 4 G[4,5] m1202 p25 mean median p75 Ohne Beruf~s 1 29 42.627213 46 55 duale o. s~l 2 39 47.076531 49 56 Aufstiegsf~T 3 41 48.092344 50 56 Fachhochsc~h 4 39 47.760744 49 57 2.7 Von der matrix zum Datensatz Mit xsvmat bzw. dem ado xsvmat können wir eine matrix in einen Datensatz umwandeln. Mit rownames(lab) können wir Zeilennamen in die Variable lab ablegen. Außerdem nutzt xsvmat die neue frame- Funktion, um einen neuen Datensatz zu erstellen. ssc install xsvmat xsvmat G, names(col) frame(res1) rownames(lab) frame change res1 list, noobs clean lab m1202 p25 mean median p75 Ohne Berufsabschluss 1 29 42.62721 46 55 duale o. schulische Berufsausbildung/einf.,mittl. Beamte 2 39 47.07653 49 56 Aufstiegsfortbildung (Meister, Techniker, kfm. AFB u.ä.) 3 41 48.09234 50 56 Fachhochschule, Universität/ geh., höhere Beamte 4 39 47.76074 49 57 2.8 frame: mehrere Datensätze in Stata Die frame-Option basiert auf einer relativ neuen Funktion in Stata. Seit Version 16 bietet Stata mit den frame-Befehlen auch die Möglichkeit, mehrere Datensätze parallel zu bearbeiten. mit frame create nameX können wir einen neuen Datensatz mit dem Namen nameX erstellen (der bisherige wird als default bezeichnet) mit frame dir bekommen wir eine Übersicht zu den verschiedenen frames der aktuellen Stata-Session mit frame change name können wir zwischen den verschiedenen frames hin- und herspringen frame change res1 frame change default mit frame drop name können wir einen frame wieder löschen: frame drop res1 Übung 2.9 Übungen 2.9.1 Übung Zählen Sie die Wörter in den folgenden beiden String-locals loc x1 &quot;ein sehr langer satz mit vielen wörtern&quot; ds *wib* loc x2 = r(varlist) Wie würde eine Schleife aussehen, die jeweils ein Wort aus den locals nacheinander mit display ausgibt? 2.9.2 Übung Laden Sie die Erwerbstätigenbefragung - am besten in der Version ohne Missings in den relevanten Variablen ( \"${data}/BIBBBAuA_2018_suf1.0_clean.dta\", siehe 01_init.do) Erstellen Sie eine Schleife, welche jeweils das Maximaleinkommen (basierend auf F518_SUF) für die Gemeindegrößenklassen (gkpol) anzeigt. Wie kommen Sie an den Maximalwert für F518_SUF? Verwenden Sie bspw. su oder tabstat zusammen mit return list. Erstellen Sie mit display eine aussagekräftige Ausgabe Testen Sie Ihre Schleifenlogik mit einem local, um anschließend die Schleife “außen herumzubauen” Welche Ausprägungen hat gkpol - wie können Sie diese automatisch in eine Schleife überführen? Optional Passen Sie Ihre Schleife an, sodass für jeden Durchlauf ein global gkX erstellt wird, wobei X für die Ausprägung von gkpol steht und den entsprechenden Maximalwert von F518_SUF für die entsprechende Größenklasse enthält. 2.9.3 Übung Kopieren Sie die in Übung 2 erstellte Schleife und passen Sie diese so an, dass jeweils die Werte für Min, Mean, Median, Max und N in matrix gesammelt werden. Verwenden Sie den row join für matrix mit , um jeweils eine Ergebniszeile zu erstellen 2.9.4 Übung Passen Ihre Schleife von eben mit gkpol so mit Hilfe der Schleife von oben so an, dass die Labels für gkpol als rownames werden legen Sie die Ergebnismatrix in einen frame ab. Nutzen Sie die label (v') 1 extended macro function um das jeweilige Label anzuzeigen Setzen Sie das entsprechende Label als rowname Fügen Sie die einzelnen Ergebnis in eine matrix zusammen Nutzen Sie xsvmat, um einen frame zu erstellen Nutzen Sie frame change, um in die Ergebnis-frame zu wechseln (und wieder zurück) "],["regres.html", "3 Regressionsergebnisse weiterverarbeiten 3.1 e() und r() der Regressionsergebnisse 3.2 Regressionstabellen als matrix speichern und anpassen 3.3 kategoriale UV 3.4 Als Datensatz ablegen: 3.5 weitere Infos aus e() 3.6 reg schrittweise aufbauen 3.7 Übungen 3.8 Anhang", " 3 Regressionsergebnisse weiterverarbeiten 3.1 e() und r() der Regressionsergebnisse Die Koeffizienten und Standardfehler des letzten Modells werden in e() gespeichert: reg F518_SUF F200 Source | SS df MS Number of obs = 14,659 -------------+---------------------------------- F(1, 14657) = 1370.76 Model | 1.3122e+10 1 1.3122e+10 Prob &gt; F = 0.0000 Residual | 1.4031e+11 14,657 9572601.57 R-squared = 0.0855 -------------+---------------------------------- Adj R-squared = 0.0855 Total | 1.5343e+11 14,658 10467142.3 Root MSE = 3094 ------------------------------------------------------------------------------ F518_SUF | Coef. Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- F200 | 109.4473 2.956134 37.02 0.000 103.6529 115.2417 _cons | -344.1221 104.2802 -3.30 0.001 -548.5245 -139.7197 ------------------------------------------------------------------------------ mat l e(b) e(b)[1,2] F200 _cons y1 109.44727 -344.12212 3.1.1 Koeffizienten mit _b / _se aufrufen Allerdings gibt es noch eine Abkürzung mit _b[varname] bzw. _se[varname]: dis &quot;Der Koeffizient für F200 ist &quot; _b[F200] dis &quot;Der Standardfehler des Koeffizienten für F200 ist &quot; _se[F200] Der Koeffizient für F200 ist 109.44727 Der Standardfehler des Koeffizienten für F200 ist 2.9561335 Wir können so auch vorhergesagte Werte berechnen - entweder für spezifische Werte: dis _b[_cons] + 20 *_b[F200] margins, at(F200 = 20) 1844.8234 Adjusted predictions Number of obs = 14,659 Model VCE : OLS Expression : Linear prediction, predict() ------------------------------------------------------------------------------ | Delta-method | Margin Std. Err. t P&gt;|t| [95% Conf. Interval] -------------+---------------------------------------------------------------- _cons | 1844.823 49.14441 37.54 0.000 1748.494 1941.153 ------------------------------------------------------------------------------ …oder für alle Beobachtungen: gen pred_manual = _b[_cons] + F200 *_b[F200] predict pred_auto, xb gen diff= pred_manual - pred_auto su diff Variable | Obs Mean Std. Dev. Min Max -------------+--------------------------------------------------------- diff | 17,376 0 0 0 0 3.1.2 Komplette Regressionstabelle Die vollständige Regressionstabelle ist aber eine r-Class matrix: reg F518_SUF F200 matlist r(table) r(table)[9,2] F200 _cons b 109.44727 -344.12212 se 2.9561335 104.28024 t 37.023793 -3.2999743 pvalue 6.36e-287 .00096924 ll 103.65288 -548.52452 ul 115.24167 -139.71973 df 14657 14657 crit 1.9601259 1.9601259 eform 0 0 3.2 Regressionstabellen als matrix speichern und anpassen Mit ' können wir die Regressionstabelle transponieren: reg F518_SUF F200 mat C = r(table)&#39; mat l C C[2,9] b se t pvalue ll ul F200 109.44727 2.9561335 37.023793 6.36e-287 103.65288 115.24167 _cons -344.12212 104.28024 -3.2999743 .00096924 -548.52452 -139.71973 df crit eform F200 14657 1.9601259 0 _cons 14657 1.9601259 0 rownumb hilft, einen Koeffizienten zu suchen: mat C1 = C[rownumb(C,&quot;F200&quot;),1...] mat l C1 C1[1,9] b se t pvalue ll ul F200 109.44727 2.9561335 37.023793 6.36e-287 103.65288 115.24167 df crit eform F200 14657 1.9601259 0 3.3 kategoriale UV Der Koeffizientenname ist etwas komplizierterer Name bei kat. UVs: reg F518_SUF i.S1 F200 ereturn list mat l r(table) dis &quot;Der Koeffizient für S1 = weiblich ist &quot; _b[2.S1] r(table)[9,4] 1b. 2. S1 S1 F200 _cons b 0 -628.91281 95.08006 464.42184 se . 55.392637 3.2038116 125.90363 t . -11.353726 29.67717 3.688709 pvalue . 9.461e-30 5.23e-188 .00022621 ll . -737.48935 88.800186 217.63489 ul . -520.33627 101.35993 711.2088 df 14656 14656 14656 14656 crit 1.9601259 1.9601259 1.9601259 1.9601259 eform 0 0 0 0 Der Koeffizient für S1 = weiblich ist -628.91281 Dies müssen wir auch bei der Suche nach einem Koeffizienten berücksichtigen: mat D = r(table)&#39; // transponieren: mat l D b se t pvalue ll ul df crit eform 1b.S1 0 . . . . . 14656 1.9601259 0 2.S1 -628.91281 55.392637 -11.353726 9.461e-30 -737.48935 -520.33627 14656 1.9601259 0 F200 95.08006 3.2038116 29.67717 5.23e-188 88.800186 101.35993 14656 1.9601259 0 _cons 464.42184 125.90363 3.688709 .00022621 217.63489 711.2088 14656 1.9601259 0 3.4 Als Datensatz ablegen: Auch hier können wir dann mit xsvmat die Matrix in einen Datensatz umformatieren: cap frame drop regres1 xsvmat D, names(col) rownames(coef) frame(regres1) frame change regres1 list, noobs clean coef b se t pvalue ll ul df crit eform 1b.S1 0 . . . . . 14656 1.960126 0 2.S1 -628.9128 55.39264 -11.35373 9.46e-30 -737.4893 -520.3362 14656 1.960126 0 F200 95.08006 3.203812 29.67717 0 88.80019 101.3599 14656 1.960126 0 _cons 464.4218 125.9036 3.688709 .0002262 217.6349 711.2088 14656 1.960126 0 3.5 weitere Infos aus e() In ereturn list oben sehen wir, dass e(cmdline) den reg-Befehl enthält: reg F518_SUF i.S1 F200 dis &quot;`e(cmdline)&#39;&quot; regress F518_SUF i.S1 F200 Diese Information können wir mit in den Ergebnis-frame nehmen. globals bleiben nehmen in der Session erhalten, auch wenn wir zwischen frames wechseln: gen mo = &quot;`e(cmdline)&#39;&quot; list, noobs clean coef b se t pvalue ll ul df crit eform mo 1b.S1 0 . . . . . 14656 1.960126 0 regress F518_SUF i.S1 F200 2.S1 -628.9128 55.39264 -11.35373 9.46e-30 -737.4893 -520.3362 14656 1.960126 0 regress F518_SUF i.S1 F200 F200 95.08006 3.203812 29.67717 0 88.80019 101.3599 14656 1.960126 0 regress F518_SUF i.S1 F200 _cons 464.4218 125.9036 3.688709 .0002262 217.6349 711.2088 14656 1.960126 0 regress F518_SUF i.S1 F200 Diese Beschreibung ist natürlich alles andere als ideal. Im nächsten Kapitel werden wir einige Möglichkeiten kennenlernen, da etwas zu ändern. Übung 3.5.1 e(sample) e(sample) ist eine e()-Class Funktion, welche die in einem Modell berücksichtigten Fälle zu markieren: quietly reg F518_SUF i.S1 F200 gen smpl = e(sample) tab sampl smpl | Freq. Percent Cum. ------------+----------------------------------- 0 | 5,353 26.75 26.75 1 | 14,659 73.25 100.00 ------------+----------------------------------- Total | 20,012 100.00 So können wir bspw. sehen, wo die Missings liegen: mdesc F518_SUF S1 F200 if smpl == 0 quietly{ use &quot;./data/BIBBBAuA_2018_suf1.0_clean.dta&quot;, replace reg F518_SUF i.S1 F200 gen smpl = e(sample) } mdesc F518_SUF S1 F200 if smpl == 0 Variable | Missing Total Percent Missing ----------------+----------------------------------------------- F518_SUF | 3,377 5,353 63.09 S1 | 0 5,353 0.00 F200 | 2,636 5,353 49.24 ----------------+----------------------------------------------- 3.6 reg schrittweise aufbauen glo mod1 i.S1 az i.m1202 zpalter i.Mig qui regress F518_SUF ${mod1} gen smpl2 = e(sample) local len2: word count ${mod1} forvalues i = 1(1)`len2&#39; { loc word: word `i&#39; of ${mod1} dis &quot;Modell Nr&quot; `i&#39; &quot;: mit `word&#39;&quot; loc x `x&#39; `word&#39; qui reg F518_SUF `x&#39; if smpl2 == 1 est store m`i&#39; } est dir esttab m*, b se // ssc install esttab Modell Nr1: mit i.S1 Modell Nr2: mit az Modell Nr3: mit i.m1202 Modell Nr4: mit zpalter Modell Nr5: mit i.Mig ---------------------------------------------------------------- name | command depvar npar title -------------+-------------------------------------------------- m1 | regress F518_SUF 3 Linear regression m2 | regress F518_SUF 4 Linear regression m3 | regress F518_SUF 8 Linear regression m4 | regress F518_SUF 9 Linear regression m5 | regress F518_SUF 12 Linear regression ---------------------------------------------------------------- -------------------------------------------------------------------------------------------- (1) (2) (3) (4) (5) F518_SUF F518_SUF F518_SUF F518_SUF F518_SUF -------------------------------------------------------------------------------------------- 1.S1 0 0 0 0 0 (.) (.) (.) (.) (.) 2.S1 -1434.1*** -683.3*** -725.7*** -755.7*** -756.4*** (53.94) (55.19) (53.65) (53.50) (53.51) az 91.74*** 83.46*** 84.05*** 83.99*** (2.376) (2.323) (2.315) (2.316) 1.m1202 0 0 0 (.) (.) (.) 2.m1202 384.1*** 261.9* 250.9* (114.5) (114.6) (115.2) 3.m1202 898.1*** 737.2*** 724.5*** (137.7) (137.9) (138.5) 4.m1202 2074.7*** 1933.3*** 1924.7*** (116.0) (116.2) (116.7) zpalter 25.41*** 25.27*** (2.200) (2.210) 0.Mig 0 (.) 1.Mig 10.65 (93.55) 2.Mig -175.8 (146.9) _cons 4236.3*** 359.5*** -376.7** -1447.4*** -1423.9*** (37.72) (106.7) (141.0) (168.3) (171.2) -------------------------------------------------------------------------------------------- N 16518 16518 16518 16518 16518 -------------------------------------------------------------------------------------------- Standard errors in parentheses * p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001 Übung 3.7 Übungen 3.7.1 Übung Erstellen Sie folgendes Regressionsmodell: reg az i.mig01 zpalter (In mig01 steht dann 0 für keinen Migrationshintergrund und 1 für Migrationshintergrund - siehe auch 01_init.do) Erstellen Sie jeweils einen display-Befehl, der den Koeffizienten und Standardfehler für mig01 und zpalter mit einer Aussagekräftigen Nachricht ausgibt Wie würde das als Schleife über die Koeffizienten aussehen? Extrahieren Sie die Regressionstabelle als matrix und legen sie diese als frame ab. Erstellen Sie zusätzlich eine Spalte mit dem Regressionsbefehl. 3.7.2 Übung Bauen Sie folgendes Modell Schritt für Schritt auf und lassen Sie sich die Tabelle mit esttab ausgeben: reg az i.S1 zpalter c.zpalter#c.zpalter i.gkpol i.F1604 i.F1604##i.S1 3.8 Anhang 3.8.1 statsby statsby _b _se, by(Bula) noisily: /// regress F518_SUF c.F200##c.F200 i.m1202 i.S1 3.8.2 reg-Ergebnisse für Modelle sammeln: Schleife Wir können mit den matrix-Befehlen auch eine Schleife bauen, welche eine Reihe an Regressionsmodellen schätzt und bei jedem Durchlauf einen zusätzlichen Term hinzunimmt. Wir interessieren uns aber nur, dafür wie sich der Koeffizient für das Geschlecht (S1 == 2) entwickelt mit jedem neuen Modell. Mit den matrix-Befehlen können wir dieser herausfiltern. local predictors i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter // UV-Liste local r = 1 // Zähler loc uv // uv rücksetzen (zur sicherheit) foreach v of local predictors { local uv `uv&#39; `v&#39; qui regress F518_SUF `uv&#39; mat D = r(table)&#39; // reg-tabelle transponieren &amp; speichern mat D2 = D[rownumb(D,&quot;2.S1&quot;),1...] // Koeffizient für S1=2 behalten if (`r&#39; == 1) mat R = D2 // im ersten Durchlauf R erstellen if (`r&#39; != 1) mat R = R\\D2 // danach: D2 an R anfügen loc ++r // Zähler + 1 } mat l R R[6,9] b se t pvalue ll ul df crit eform 2.S1 -1431.8093 53.630001 -26.697917 8.52e-154 -1536.9298 -1326.6888 16633 1.9601066 0 2.S1 -628.91281 55.392637 -11.353726 9.461e-30 -737.48935 -520.33627 14656 1.9601259 0 2.S1 -661.6656 55.679749 -11.883416 2.034e-32 -770.80492 -552.52628 14655 1.9601259 0 2.S1 -664.94219 53.793012 -12.361126 6.336e-35 -770.38328 -559.50111 14633 1.9601261 0 2.S1 -700.71303 54.028438 -12.969337 2.975e-38 -806.61563 -594.81043 14552 1.960127 0 2.S1 -717.33567 54.061055 -13.268991 5.977e-40 -823.30221 -611.36914 14551 1.960127 0 Wie wissen wir jetzt, für was kontrolliert wurde? Wir nutzen den Zähler, um ein global mit der Zählernummer zu erstellen und eine Zeile in die matrix einzufügen: local predictors i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter local r = 1 // Zähler loc uv // uv rücksetzen (zur sicherheit) foreach v of local predictors { local uv `uv&#39; `v&#39; qui regress F518_SUF `uv&#39; mat D = r(table)&#39; // reg-tabelle transponieren &amp; speichern mat D2 = D[rownumb(D,&quot;2.S1&quot;),1...] // Koeffizient für S1=2 behalten mat M = `r&#39; mat colname M = mod if (`r&#39; == 1) mat R = D2 , M // ,r -&gt; zähler an Koeffizientzeile anfügen if (`r&#39; != 1) mat R = R\\(D2 , M) glo cmd`r&#39; = &quot;`e(cmdline)&#39;&quot; loc ++r // Zähler + 1 } mat l R R[6,10] b se t pvalue ll ul df crit eform mod 2.S1 -1431.8093 53.630001 -26.697917 8.52e-154 -1536.9298 -1326.6888 16633 1.9601066 0 1 2.S1 -628.91281 55.392637 -11.353726 9.461e-30 -737.48935 -520.33627 14656 1.9601259 0 2 2.S1 -661.6656 55.679749 -11.883416 2.034e-32 -770.80492 -552.52628 14655 1.9601259 0 3 2.S1 -664.94219 53.793012 -12.361126 6.336e-35 -770.38328 -559.50111 14633 1.9601261 0 4 2.S1 -700.71303 54.028438 -12.969337 2.975e-38 -806.61563 -594.81043 14552 1.960127 0 5 2.S1 -717.33567 54.061055 -13.268991 5.977e-40 -823.30221 -611.36914 14551 1.960127 0 6 Diese matrix R schicken wir jetzt in einen frame: cap frame drop rmods xsvmat R, names(col) rownames(coef) frame(rmods) frame change rmods list, noobs clean coef b se t pvalue ll ul df crit eform mod 2.S1 -1431.809 53.63 -26.69792 0 -1536.93 -1326.689 16633 1.960107 0 1 2.S1 -628.9128 55.39264 -11.35373 9.46e-30 -737.4893 -520.3362 14656 1.960126 0 2 2.S1 -661.6656 55.67975 -11.88342 2.03e-32 -770.8049 -552.5263 14655 1.960126 0 3 2.S1 -664.9422 53.79301 -12.36113 6.34e-35 -770.3833 -559.5011 14633 1.960126 0 4 2.S1 -700.713 54.02844 -12.96934 2.97e-38 -806.6156 -594.8104 14552 1.960127 0 5 2.S1 -717.3357 54.06105 -13.26899 0 -823.3022 -611.3691 14551 1.960127 0 6 Jetzt wissen zwar schon mal, aus welchem Modell der Koeffizient jeweils kommt (basierend auf mod). Eigentlich würden das aber gerne labeln. Dazu können wir jetzt auf die globals zurückgreifen - mit all globals können wir nach ihnen suchen: global allglo: all globals &quot;cmd*&quot; mac l allglo allglo: cmd6 cmd5 cmd4 cmd3 cmd2 cmd1 mac l cmd1 cmd1: regress F518_SUF i.S1 Jetzt können wir mit einer Schleife die Spalte mod labeln. Mit label define .... können Wertelabels erstellt werden - mit der Option ,modify können wir das auch schrittweise verändern. Außerdem können wir einen kleinen Trick nutzen, um innerhalb der Schleife auf das global mit einer bestimmten Zahl zuzugreifen: levelsof mod, loc(mnrs) foreach m of local mnrs { lab def mod_lab `m&#39; &quot;${cmd`m&#39;}&quot;, modify // value label verändern } lab val mod mod_lab list, noobs clean coef b se t pvalue ll ul df crit eform mod 2.S1 -1431.809 53.63 -26.69792 0 -1536.93 -1326.689 16633 1.960107 0 regress F518_SUF i.S1 2.S1 -628.9128 55.39264 -11.35373 9.46e-30 -737.4893 -520.3362 14656 1.960126 0 regress F518_SUF i.S1 c.F200 2.S1 -661.6656 55.67975 -11.88342 2.03e-32 -770.8049 -552.5263 14655 1.960126 0 regress F518_SUF i.S1 c.F200 c.F200#c.F200 2.S1 -664.9422 53.79301 -12.36113 6.34e-35 -770.3833 -559.5011 14633 1.960126 0 regress F518_SUF i.S1 c.F200 c.F200#c.F200 i.m1202 2.S1 -700.713 54.02844 -12.96934 2.97e-38 -806.6156 -594.8104 14552 1.960127 0 regress F518_SUF i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter 2.S1 -717.3357 54.06105 -13.26899 0 -823.3022 -611.3691 14551 1.960127 0 regress F518_SUF i.S1 c.F200 c.F200#c.F200 i.m1202 zpalter c.zpalter#c.zpalter Daraus können wir beispielsweise einen Koeffizientenplot erstellen: graph twoway /// (rcap ll ul mod,horizontal lcolor(&quot;57 65 101&quot;) ) /// Konfidenzintervalle (scatter mod b, mcolor(&quot;177 147 74&quot;) ) , /// Punktschätzer graphregion(fcolor(white)) /// Hintergundfarbe (außerhalb des eigentlichen Plots) ylabel(, valuelabel angle(0) labsize(tiny)) /// legend(off) /// xtitle(&quot;Einkommen (W) vs. Einkommen (M)&quot;) /// Achsentitel ytitle(&quot;&quot;) /// title(&quot;Titel&quot;) /// subtitle(&quot;Untertitel&quot;) /// caption(&quot;{it:Quelle: Erwerbstätigenbefragung 2018}&quot;, size(8pt) position(5) ring(5) ) Error in knitr::include_graphics(&quot;./graph/Regplot.png&quot;): Cannot find the file(s): &quot;./graph/Regplot.png&quot; Diese labels sind natürlich alles andere als ideal. Im nächsten Kapitel werden wir einige Möglichkeiten kennenlernen, da etwas zu ändern. "],["labmacro.html", "4 Label- und Variablenfunktionen 4.1 Stringfunktionen 4.2 Arbeiten mit “Regular Expressions” 4.3 Label bearbeiten 4.4 Abgleiche 4.5 wo kommt überall -4 vor? 4.6 Übungen 4.7 Anhang", " 4 Label- und Variablenfunktionen Inspiriert von der UCLA einige Beispielstrings: clear all input str60 add &quot;4905 Lakeway Drive, College Station, Texas 77845 USA&quot; &quot;673 Jasmine Street, Los Angeles, CA 90024&quot; &quot;2376 First street, San Diego, CA 90126&quot; &quot;6 West Central St, Tempe AZ 80068&quot; &quot;1234 Main St. Cambridge, MA 01238-1234&quot; &quot;Robert-Schuman-Platz 3, 53175 Bonn GERMANY&quot; &quot;Regensburger Straße 100, 90478 Nürnberg Germany&quot; &quot; Ammerländer Heerstraße 114-118, 26129 Oldenburg GERMANY &quot; end 4.1 Stringfunktionen help string functions gen x1 = substr(add,5,10) // substring von add -&gt; Zeichen 5-10 gen x2 = wordcount(add) // Worte zählen gen x3 = word(add,5) // 5. Wort gen x4 = upper(add) // alles groß gen x5 = lower(add) // alles klein gen x6 = proper(add) // jeweiles erster Buchstabe eines Wortes groß gen x7 = trim(add) // Leerzeichen am Ende und Beginn raus gen x8 = strlen(add) // Anzahl der Zeichen in add Allerdings sind diese Funktionen auf ASCII-Zeichen ausgelegt - einfach gesagt: Umlaute, ß usw. bereiten Probleme. Daher gibt es eine Erweiterung mit usubstr, ustrupper(), ustrlower() usw. - mehr dazu jeweils in der Hilfe. Der Weg zur passenden regex string-Funktion ist leider oft von vielen Versuchen begleitet, am einfachsten testet man mit display. So zeigt sich hier bspw., dass proper() hier “ß” und “ü” als Wortende/-beginn (mis-)versteht: display proper(&quot;Regensburger Straße 100, 90478 nüRnberg germany&quot;) Regensburger StraßE 100, 90478 NüRnberg Germany …in der Hilfe finden wir ustrtitle: display ustrtitle(&quot;Regensburger Straße 100, 90478 nüRnberg germany&quot;) Regensburger Straße 100, 90478 Nürnberg Germany Hier wenig hilfreich, aber häufig eine gute Abkürzung: split Mit parse() können wir einen Trenner angeben. split add, parse(&quot; &quot;) gen(t) Übung Tipp: real() ist deutlich schneller und unkomplizierter als destring clear all input str1 x1 &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;23&quot; &quot;21&quot; &quot;2&quot; &quot;--&quot; &quot;2&quot; end gen num = real(x1) list destring(x1), gen(num2) x1 1. &quot;2&quot; 2. &quot;3&quot; 3. &quot;5&quot; 4. &quot;23&quot; 5. &quot;21&quot; 6. &quot;2&quot; 7. &quot;--&quot; 8. &quot;2&quot; 9. end (1 missing value generated) +----------+ | x1 num | |----------| 1. | 2 2 | 2. | 3 3 | 3. | 5 5 | 4. | 2 2 | 5. | 2 2 | |----------| 6. | 2 2 | 7. | - . | 8. | 2 2 | +----------+ x1: contains nonnumeric characters; no generate 4.2 Arbeiten mit “Regular Expressions” “regular expressions” oder “regex” sind eine flexible Methode, strings (also Textinhalte) zu durchsuchen. Dabei suchen wir nach Mustern anstelle eines exakten matchings. In Stata können wir regex für Variablen, aber auch für macros und Labels verwenden. regex sind aber nicht immer die (einfachste) Lösung und oft werden die Befehle sehr unübersichtlich. Daher hier nur ein kurzer Überblick. Die drei Hauptfunktionen in Stata finden wir unter help regex: regexm(s,re) allows you to search for the string described in your regular expressions. It evaluates to 1 if the string matches the expression. regexs(n) returns the nth substring within an expression matched by regexm (hence, regexm must always be run before regexs). regexr(s1,re,s2) searches for re within the string (s1) and replaces the matching portion with a new string (s2). Allerdings sind diese Funktionen auf ASCII-Zeichen ausgelegt - einfach gesagt: Umlaute, ß usw. bereiten Probleme. Daher gibt es eine Erweiterung mit ustrregexm, ustrregexs, ustrregexrf und ustrregexra. Auf die konzentrieren wir uns hier. 4.2.1 regex (Grund-)Regeln regex basieren auf einer Reihe an Zeichen, mit Hilfe derer wir strings durchsuchen können: \\d matcht eine Zahl \\w matcht “alphanumeric characters” (Buchstaben &amp; Zahlen) \\s matcht ein Leerzeichen ^ “matche Ausdruck am Anfang des strings” $ “matche Ausdruck am Ende des strings” - lässt eine range zu: a-z, 0-9, 5-8, F-M etc. . bedeutet “matche irgendein Zeichen” \\ ist ein “escape character” für Zeichen, die ansonsten als regex-Operator verstanden würden | oder-Operator [] use in matching, such as [a-zA-Z0-9] for all alphanumeric characters () darin angegebene Werte können wir mit ustrregexs extrahieren * “matche 0 oder öfter” für den vorhergehenden Ausdruck + “matche 1 oder öfter” für den vorhergehenden Ausdruck 4.2.2 Beispiele Inspiriert von der UCLA einige Beispielstrings: clear all input str60 add &quot;4905 Lakeway Drive, College Station, Texas 77845 USA&quot; &quot;673 Jasmine Street, Los Angeles, CA 90024&quot; &quot;2376 First street, San Diego, CA 90126&quot; &quot;6 West Central St, Tempe AZ 80068&quot; &quot;1234 Main St. Cambridge, MA 01238-1234&quot; &quot;Robert-Schuman-Platz 3, 53175 Bonn GERMANY&quot; &quot;Regensburger Straße 100, 90478 Nürnberg Germany&quot; &quot;Ammerländer Heerstraße 114-118, 26129 Oldenburg GERMANY&quot; end gen d = ustrregexm(add, &quot;GERMANY|Germany&quot;) Das m in ustrregexm steht für match. Mit ustrregexm können wir nach Zeichenketten suchen. Wenn sie gefunden wird, wird eine 1 zurückzugeben, andernfalls 0. Hier suchen wir nach “entweder GERMANY oder Germany”. Wir können aber auch den gefundenen Inhalt extrahieren. Bei Übereinstimmungen werden die matches gespeichert, darauf können wir mit ustrregexs zurückgreifen: gen d2 = ustrregexs(0) if ustrregexm(add, &quot;GERMANY|Germany&quot;) s steht für subexpressions (oder “tokens”). Token 0 enthält alle übereinstimmenden Muster. Wird eine Zeichenkette mehrfach gefunden, dann enthält Token 0 alle Übereinstimmungen, Token 1 die erste, Token 2 die zweite und so weiter. ustrregexrf und ustrregexra helfen uns schließlich, Inhalte zu ersetzen. rf bzw. ra stehen dabei für “replace first” bzw. “replace all”. ustrregexrf ersetzt also nur den ersten match, ustrregexra hingegen alle. Basierend auf den Regeln von oben ergeben diese beiden Befehle unterschiedliche Ergebnisse: gen s1 = ustrregexra(add, &quot;street&quot;, &quot;!&quot;) gen s2 = ustrregexra(add, &quot;[street]&quot;, &quot;!&quot;) In s1 wurden alle matches “street” gelöscht und durch ! ersetzt. In s2 wurden alle matches von “s”,“t”,“r”,“e” und “t” gelöscht und durch ! ersetzt. Weitere Beispiele für ersetzen mit regex-Regelausdrücken - siehe DoFile: gen z1 = ustrregexra(add, &quot;\\w&quot;, &quot;&quot;) // alle alphanumeric ersetzen gen z2 = ustrregexra(add, &quot;\\W&quot;, &quot;&quot;) // alle nicht-alphanumeric ersetzen gen z3 = ustrregexra(add, &quot;\\d&quot;, &quot;&quot;) // alle Zahlen ersetzen gen z4 = ustrregexra(add, &quot;\\D&quot;, &quot;&quot;) // alle nicht-Zahlen ersetzen gen z5 = ustrregexra(add, &quot;.+,&quot;, &quot;&quot;) // alles vor dem Komma ersetzen gen z6 = ustrregexra(add, &quot;,.+&quot;, &quot;&quot;) // alles nach dem Komma ersetzen Nach Zahlen suchen: gen r1 = ustrregexs(0) if ustrregexm(add, &quot;\\d&quot;) // Zahl gen r2 = ustrregexs(0) if ustrregexm(add, &quot;\\d+&quot;) // Zahlenfolge gen r3 = ustrregexs(0) if ustrregexm(add, &quot;(\\d{5})&quot;) // 5-stellige Zahl gen r4 = ustrregexs(0) if ustrregexm(add, &quot;^(\\d+)&quot;) // Zahlenfolge am Anfang gen r5 = ustrregexs(0) if ustrregexm(add, &quot;(\\d+).*(\\d+)&quot;) // Zahlenfolgen und alles was dazwischen kommt gen r6 = ustrregexs(0) if ustrregexm(r5, &quot;(\\d+)$&quot;) // Zahlenfolge am Ende -&gt; aus r5! 4.2.3 Weiterführende Links Hier findet sich ein sehr gutes “Cheatsheet” zu den gebräuchlichsten regex. Das zugehörige Tutorial ist ebenfalls sehr lesenswert. Die Übersicht der UCLA bietet auch nochmal einige Hinweise - allerdings auf Basis der ASCII-basierten Befehle. Stata Hilfe Hier findet sich ein weiteres hilfreiches Tutorial Übung 4.3 Label bearbeiten Um Informationen zu Variablen &amp; Labels abzurufen, stehen eine ganze Reihe an extended macro functions zur Verfügung: loc v m1202 local vartype: type `v&#39; // Variablen &quot;storage type&quot; (byte etc) local varlab: variable label `v&#39; // variable label local vallabname: value label `v&#39; // Name des value label local vallab1 : label (`v&#39;) 1 // Value label für Wert = 1 Die so erstellten locals können wir dann in der bekannten Methode wieder darstellen: di &quot;`vartype&#39;&quot; // display local &quot;vartype&quot; di &quot;`varlab&#39;&quot; // display local &quot;varlabel&quot; di &quot;`vallabname&#39;&quot; // display local &quot;valuelabname&quot; di &quot;`vallab1&#39;&quot; // display local &quot;valuelab1&quot; Wir können die Labels und Eigenschaften von `v’ auch in einem Schritt anzeigen lassen, die Syntax sieht aber etwas eigenwillig aus: loc v m1202 di &quot;`: type `v&#39;&#39;&quot; // &quot;storage type&quot; (byte etc) der Variable di &quot;`: variable label `v&#39;&#39;&quot; // variable label di &quot;`: value label `v&#39;&#39;&quot; // Name des value label di &quot;`: label (`v&#39;) 1&#39;&quot; // Value label für Wert = 1 Damit können wir bspw. ein Variable Label kürzen: local longlabel: var label m1202 // variable label für variable m1202 suchen local shortlabel = substr(&quot;`longlabel&#39;&quot;,1,10) // verändern mit string Funktion label var m1202 &quot;`shortlabel&#39;&quot; // anwenden Um an die Value Labels zu kommen, braucht es etwas mehr: local lblname: value label m1202 // value labels für variable m1202 suchen cap label drop `lblname&#39;_n //neuen namen droppen zur Sicherheit label copy `lblname&#39; `lblname&#39;_n // value labelbook kopieren local lab1: label (m1202) 2 // value label für Wert = 2 aufrufen loc lab2 = upper(&quot;`lab1&#39;&quot;) // dieses value labels verändern label define `lblname&#39;_n `lvl&#39; &quot;`lab2&#39;&quot;, modify // in neues value labelbook einfügen labelbook `lblname&#39; `lblname&#39;_n // vergleich alt vs neu Mit label copy oldname newname, local lblname: value label var und local lab1: label (var) level können wir auch value-Labels bearbeiten: loc v m1202 local lblname: value label `v&#39; // value label aufrufen cap label drop `lblname&#39;_n // neuen Namen zur Sicherheit droppen label copy `lblname&#39; `lblname&#39;_n // kopieren levelsof `v&#39;, loc(x) // Werte für die Variable aufrufen foreach lvl of local x { local lab1: label (`v&#39;) `lvl&#39; // Value label Variable v bei Level lvl loc lab2 = substr(&quot;`lab1&#39;&quot;,1,8) // kürzen label define `lblname&#39;_n `lvl&#39; &quot;`lab2&#39;&quot;, modify // im neuen value label ändern } lab val `v&#39; `lblname&#39;_n // anwenden Übung 2 4.4 Abgleiche Existiert eine Variable? capture confirm variable lm02 if !_rc dis &quot;ja&quot; if _rc dis &quot;nein&quot; Ist variable numerisch? capture confirm numeric variable az if !_rc dis &quot;ja&quot; if _rc dis &quot;nein&quot; ja help data_types 4.5 wo kommt überall -4 vor? quietly ds local varlist1 `r(varlist)&#39; *display &quot;`varlist1&#39;&quot; foreach v of varlist1 { qui count if `v&#39; == -4 if r(N) &gt; 0 display &quot;`v&#39;&quot; } * oder direkt: foreach v of varlist * { qui count if `v&#39; == -4 if r(N) &gt; 0 display &quot;`v&#39;&quot; } Übung 4.6 Übungen 4.6.1 Übung Verwenden Sie mit input die Adressdaten von oben Wie kommen Sie jeweils an das vorletzte Wort aus der Adressliste? Extrahieren Sie die zehn letzten Zeichen aus add, aber lassen die drei letzten Zeichen weg. (“Zeichen 10 bis 4 von hinten her gezählt”). 4.6.2 Übung Laden Sie den regex.dta: use \"https://github.com/filius23/StataProgBIBB/raw/main/docs/regex1.dta\", clear und teilen Sie die Informationen aus address in 4 Variablen auf: Hausnummer (erste Zahl), Straße, PLZ, Region Wandeln Sie alle Einträge in Großbuchstaben um Verwenden Sie split mit geeignetem parse()-Argument, um zwischen Hausnummer &amp; Straße und PLZ &amp; Region zu trennen. Wie können Sie jetzt die Zahlen vom Text trennen? (Tipp: Suchen Sie erst nach den Zahlen. Tipp2: Was wollen wir dann in den Textvariablen nicht mehr?) Löschen Sie ggf. Leerzeichen zu Beginn und am Ende der Variablen 4.6.3 Übung Laden Sie der Erwerbstätigenbefragung Kürzen die die variable labels für alle Variablen mit “wissensintensiver Beruf” im Label (d *wib*) Ersetzen Sie “wissensintensiver Beruf” in den variable labels mit “wib”. Spielen Sie die Routine erst für eine Variable durch: welche Label-Befehle brauchen Sie? Denken Sie an foreach ... of varlist und die Möglichkeit, wildcards zu verwenden. Alternativ hilft evtl. auch ds mit Wildcards So können Sie überpürfen, ob das geklappt hat: d *wib* Bearbeiten Sie das value label für nuts2 - nutzen Sie dafür die regex und string-Funktionen von oben Löschen Sie “Statistische” aus den den value labels und ersetzen Sie “Direktionsbezirk” durch “Bezirk”: tab nuts2 Kehren Sie die Codierung vom m1202 um: gen m1202_n = 10 - m1202 und passen Sie die value labels entsprechend an die neue Codierung an. Tipp: auch die value labels müssen dann jeweils 10 - x genommen werden. Für alle, die schon fertig sind: Wie könnten Sie automatisiert den Variable label für die Muttersprachenvariablen (F1606_*) kürzen, sodass statt “Muttersprache:” nur noch “MSpr” im label steht? 4.6.4 Übung In welchen Variablen aus der Erwerbstätigenbefragung kommt der der Wert -9 vor? Füttern Sie diese Information in mvdecode, um die Missings zu überschreiben. Sammeln Sie die Information, welche Variablen -9 enthalten (Stichwort rekursive macro-Definition) Erstellen Sie einen mvdecode-Befehle, welcher die Information aufnimmt und in allen gefundenen Variablen -9 durch . ersetzt. 4.7 Anhang Variablen mit bestimmten Eigenschaften identifizieren in ein macro ds, has(type byte) loc bytevars `r(varlist)&#39; foreach v of local bytevars { rename `v&#39; b_`v&#39; } "],["data.html", "5 Dateien- und DoFile-Verwaltung 5.1 dir - alles einlesen 5.2 Verzeichnisse &amp; DoFiles erstellen 5.3 Master DoFile 5.4 Übungen 5.5 Anhang", " 5 Dateien- und DoFile-Verwaltung 5.1 dir - alles einlesen glo pfad &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataProgBIBB\\projekt&quot; global filelist: dir . files &quot;*.*&quot; //Lister aller Dateien mac l filelist global dtalist: dir &quot;${pfad}&quot; files &quot;baua*.dta&quot; // Liste aller .dta-Dateien mac l dtalist loc usefile `: word 1 of ${dtalist}&#39; // erster Eintrag aus der Liste dis &quot;${pfad}/`usefile&#39;&quot; use &quot;${pfad}/`usefile&#39;&quot;, clear // dta laden loc n_datasets : list sizeof global(dtalist) // anzahl dta einträge foreach i of numlist 2(1)`n_datasets&#39; { loc appendfile `: word `i&#39; of ${dtalist}&#39; // name aus list aufrufen qui append using &quot;${pfad}/`appendfile&#39;&quot; // append dis &quot;`appendfile&#39; appended&quot; // Kontrolle } , respectcase: global dtalist: dir \"${pfad}\" files \"baua*.dta , respectcase\" würde “BAUA.dta” ignorieren. 5.1.1 copy Mit copy können wir Dateien kopieren. loc usefile `: word 1 of ${dtalist}&#39; // erster Eintrag aus der Liste loc copyfile &quot;copy_`usefile&#39;&quot; dis &quot;`usefile&#39;&quot; dis &quot;`copyfile&#39;&quot; copy ${pfad}/`usefile&#39; ${pfad}/`copyfile&#39; , replace // hat das geklappt? global dtalist2: dir &quot;${pfad}&quot; files &quot;*baua*.dta&quot; // Liste aller .dta-Dateien mac l dtalist mac l dtalist2 5.1.2 erase Mit erase können wir Dateien löschen. loc usefile `: word 1 of ${dtalist}&#39; // erster Eintrag aus der Liste loc copyfile &quot;copy_`usefile&#39;&quot; erase ${pfad}/`copyfile&#39; // hat auch das geklappt? global dtalist3: dir &quot;${pfad}&quot; files &quot;*baua*.dta&quot; // Liste aller .dta-Dateien mac l dtalist mac l dtalist2 mac l dtalist3 Übung 5.2 Verzeichnisse &amp; DoFiles erstellen Mit mkdir können wir Verzeichnisse erstellen: global pfad &quot;D:\\oCloud\\Home-Cloud\\Lehre\\BIBB\\StataProgBIBB\\projekt&quot; mkdir &quot;${pfad}/data&quot; mkdir &quot;${pfad}/log&quot; mkdir &quot;${pfad}/graph&quot; mkdir &quot;${pfad}/results&quot; mkdir &quot;${pfad}/tables&quot; file können wir nutzen, um ein DoFile mit globals zu erstellen (oder natürlich auch locals oder allen anderen Informationen): *erstelle doFile fuer macros -&gt; kurzes doFile um Pfade in Schleifen richtig zu setzen, wird dann in Schleifen immer aufgerufen file open macros using ${prog}\\macrodofile.do, write replace file write macros &quot;glo pfad ${pfad} &quot; _n file write macros &quot;glo orig ${orig} &quot; _n file write macros &quot;glo data ${data} &quot; _n file write macros &quot;glo log ${log} &quot; _n file write macros &quot;glo res ${results}&quot; _n file write macros &quot;glo graph ${graph} &quot; _n file write macros &quot;glo prog ${prog} &quot; _n file close macros 5.3 Master DoFile 5.3.1 DoFile mit Argumenten starten Ein DoFile kann auch direkt aus einem Master-DoFile gestartet werden. Werte, die wir danach angeben, können im DoFile mit der Angabe der Position abgerufen werden: do &quot;${prog}/051_DoFile.do&quot; 2 use &quot;${orig}/BIBBBAuA_2018_suf1.0.dta&quot;, clear dis &quot;Auszählung für `1&#39;&quot; tab S1 if m1202 == `1&#39; do &quot;${prog}/051_DoFile2.do&quot; 4 2 mobil local ausb `1&#39; local gend `2&#39; local var `3&#39; use &quot;${orig}/BIBBBAuA_2018_suf1.0.dta&quot;, clear dis &quot;Auszählung für Ausbildung = `ausb&#39; &amp; Geschlecht = `gend&#39;&quot; tab gkpol if m1202 == `ausb&#39; &amp; S1 == `gend&#39; tab gkpol `var&#39; if m1202 == `ausb&#39; &amp; S1 == `gend&#39; 5.3.2 in neuer Session starten cd ${prog} winexec `c(sysdir_stata)&#39;StataSE-64.exe do &quot;${prog}/052_DoFile1.do&quot; 4 2 mobil Startet 052_DoFile1.do in einer neuen Session. Achtung: hier sind dann auch die globals, locals usw. weg. Um die globals zu übernehmen, muss dann ein macrodofile eingebunden werden. 5.3.3 mehrere Sessions starten forvalues s = 1/2{ cd ${prog} winexec `c(sysdir_stata)&#39;StataSE-64.exe do &quot;${prog}/052_DoFile1.do&quot; 4 `s&#39; mobil } Übung 5.4 Übungen 5.4.1 Übung Im zip-Ordner dir_übung.zip finden sich auch .csv-Dateien. Lesen Sie diese nach der Reihe ein und speichern Sie die Daten als .dta - danach können alle Datensätze zusammengefügt werden. Entpacken Sie die Dateien aus dem zip-Ordner in passendes ein Verzeichnis (bspw., das welches Sie mit $data ansteuern). Verwenden Sie also die filelist statt der dtalist von oben. Lesen Sie mit import delimited \".... baua3.csv\", delimiter(\";\") encoding(ISO-8859-2) clear die csv-Dateien jeweils ein und legen Sie als dta ab. Anschließend können Sie den dta-Schleife von oben verwenden, um alle Teildatensätze einzulesen. Wie viele Fälle haben Sie im Datensatz? Kopieren Sie eine der Dateien und löschen Sie sie anschließend wieder. 5.4.2 Übung Starten Sie getrennte Auswertungen für Männer und Frauen für das Merkmal zpalter, bspw. mit summary und stoßen Sie dieses mit do ... an. 5.5 Anhang weitere File-Loops "],["misc.html", "6 Weitere macro &amp; matrix Funktionen 6.1 capture 6.2 Macro extended functions for parsing 6.3 weitere matrix-Befehle", " 6 Weitere macro &amp; matrix Funktionen 6.1 capture cap drop S01 zpalter d S0? zp* 6.2 Macro extended functions for parsing local wanted : di _dup(10) &quot;oo &quot; local wanted : di _dup(10) &quot;oo &quot; dis &quot;`wanted&#39;&quot; local wanted : di &quot;{dup 10:99 }&quot; oo oo oo oo oo oo oo oo oo oo 6.3 weitere matrix-Befehle Wir können auch Rechnungen einfügen: matrix X1 = (1+1, 2*3/4 \\ 5/2, 3) mat l X1 X1[2,2] c1 c2 r1 2 1.5 r2 2.5 3 6.3.1 Teilmatrizen mat X1 = (1,2,3,4,5 \\ 6,7,8,9,10 \\ 0,-1,-2,-3,-5 \\ -6,-7,-8,-9,-10) mat l X1 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 Wir können aus diesen Matrizen auch Teilbereiche auswählen: matrix newmat = oldmat[Zeile(nbereich), Spalte(nbereich)] Zeilenbereich und Spaltenbereich können einzelne Zahlen oder Bereiche mit durch zwei Punkte getrennten Start- und Endpositionen sein. Matrix B erstellen, welche die Zeile 2-4 und die Spalte 1-5 von X1 enthält: matrix B = X1[2..4,1..5] mat l B mat l X1 B[3,5] c1 c2 c3 c4 c5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 Um alle Zeilen nach der zweiten Zeile zu übernehmen, verwenden wir drei Punkte: matrix C = X1[2...,1..5] mat l C mat l X1 C[3,5] c1 c2 c3 c4 c5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 6.3.2 Spalten/Zeilen auswählen B1 enthält Spalte 1 und 3 aus X1: mat B1 = X1[1...,1],X1[1...,3] mat l B1 mat l X1 B1[4,2] c1 c3 r1 1 3 r2 6 8 r3 0 -2 r4 -6 -8 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 B2 enthält Zeile 1 und 3 aus X1: mat B2 = X1[1,1...] \\ X1[4,1...] mat l B2 mat l X1 B2[2,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r4 -6 -7 -8 -9 -10 X1[4,5] c1 c2 c3 c4 c5 r1 1 2 3 4 5 r2 6 7 8 9 10 r3 0 -1 -2 -3 -5 r4 -6 -7 -8 -9 -10 6.3.3 Namensbasierte Auswahl Hier helfen rownumb und colnumb mat X1 = (1,2,3 \\ 8,9,10 ) mat colname X1 = var1 var2 var3 mat rowname X1 = set1 set2 mat X2 = X1[rownumb(X1,&quot;set1&quot;),1...] mat l X2 X2[1,3] var1 var2 var3 set1 1 2 3 mat X3 = X1[1...,colnumb(X1,&quot;var2&quot;)] mat l X3 X3[2,1] var2 set1 2 set2 9 "],["lit.html", "7 Literatur &amp; Links", " 7 Literatur &amp; Links Stata Cookbook Stata Coding Guide Ausführliche Einführung in frames Stata Cheatsheets "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
